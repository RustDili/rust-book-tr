<!DOCTYPE HTML>
<html lang="tr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>İşlevler - Rust Progamlama Dili Türkçe Çevirisi-2021</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Önsöz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Giriş</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Kurulum</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Bir Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Ortak Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişkenlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html" class="active"><strong aria-hidden="true">3.3.</strong> İşlevler</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorumlar</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Mülkiyeti Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Mülkiyet Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Borçlanma</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlişkili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklemek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Sözdizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enum'lar ve Örüntü Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Bir Enum Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Kontrol Akışı Yapısı match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Özgün Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Sandıklar ve Modüller ile Yönetmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Sandıklar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Kapsam ve Gizlilik Kontrolü İçin Modül Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki Bir Öğeye Başvurmanın Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Anahtar Kelimesi ile Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Ortak Koleksiyonlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Değer Listelerini Vektör Kullanarak Depolamak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 Kodlu Metinleri Dizgilerle Saklamak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlere Sahip Anahtarları Eşleme Haritalarında Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamaz Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Türler, Özellikler ve Yaşam Süreleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Özellikler: Paylaşılan Davranışı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referansları Yaşam Süreleri ile  Doğrulamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatik Testler Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır?</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştırılacağını Denetlemek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir I/O Projesi: Komut Satırı Programı Oluşturmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Kabul Etmek</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Bir Dosyayı Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerlik ve Hata Yönetimini Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphane İşlevselliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenleriyle Çalışmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı Yerine Standart Hataya Yazmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> İşlevsel Dil Özellikleri: Yineleyiciler ve Kapamalar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapamalar: Ortam Değişkenlerini Yakalayabilen İsimsiz İşlevler</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyiciler ile Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performansı Karşılaştırmak: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazlası</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Derlemeleri Sürüm Profilleriyle Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Bir Sandığı Crates.io Üzerinde Yayınlamak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Crates.io Üzerindeki İkili Sandıkları cargo install Komutuyla Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo Olanaklarını Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Veriler İçin Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref Özelliğiyle Normal Referanslarmış Gibi Davranmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Temizlik Amaçlı Kod Çalıştırmak İçin Drop Özelliğini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Referans Sayılan Akıllı İşaretçi: Rc&lt;T&gt;</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişkenlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Çevrimleri Bellek Sızıntısına Yol Açabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Mesajlaşma Yardımıyla Eş Zamanlı Programlama</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşılan Durum Eşzamanlılığı</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync and Send Özellikleri ile Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'ın Nesne Yönelimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türden Değerlere İzin Veren Özellik Nesnelerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesne Yönelimli Tasarım Modeli Uygulamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Örüntüler ve Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Örüntüler Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Çürütülebilirlik: Bir Örüntünün Eşleşmeme İhtimali</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Örüntü Sözdizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Kullanım</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Özellikler</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelişmiş Kapamalar ve İşlevler</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Son Proje: Çok İş Parçacıklı Bir Web Sunucusu Oluşturmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Bir Web Sunucusu Oluşturmak</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok İş Parçacıklı Bir Sunucuya Dönüştürmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Sorunsuzca Kapatmak ve Temizlik</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Ekler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Kelimeler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - İşleçler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Özellikler</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Faydalı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitabın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust Nasıl “Nightly Rust” Yapılır? </a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Progamlama Dili Türkçe Çevirisi-2021</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="İşlevler"><a class="header" href="#İşlevler">İşlevler</a></h2>
<p>İşlevler Rust kodlarında yaygın olarak kullanılır. Dildeki en önemli işlevlerden biri olan ve programın giriş noktasını oluşturan <code>main</code> ile, yeni bir işlev bildirmeye yarayan <code>fn</code> anahtar sözcüğünü daha önce görmüştünüz.</p>
<p>Rust geleneksel olarak değişken ve işlev isimlerinde küçük harflerden oluşan ve ayrı kelimelerin alt çizgi ile birbirine bağlandığı <em>snake_case</em> tarzını kullanmaktadır.</p>
<p>Aşağıdaki programda bir işlev tanımı örneklenmektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Merhaba dünya!&quot;);

    başka_işlev();
}

fn başka_işlev() {
    println!(&quot;Bir başka işlev.&quot;);
}
</code></pre></pre>
<p>Rust'ta bir işlevi <code>fn</code> anahtar kelimesi ardından işlev adı ve bir parantez seti ile tanımlarız. Süslü parantezlerin konumu derleyiciye işlevin nerede başlayıp nerede bittiğini bildirir.</p>
<p>Halihazırda tanımlı olan bir işlev ise adı ve arkasına gelen parantez seti ile çağırılır. Örneğimizde <code>başka_işlev</code> zaten tanımlı olduğundan <code>main</code> işlevi içinden çağırılabilmektedir. Kaynak kodumuzdaki <code>başka_işlev</code>'i <code>main</code> işlevinden <em>sonra</em> tanımladığımıza dikkat edin. Rust işlevlerin nerede tanımlandığıyla ilgilenmediğinden dilerseniz işlevlerinizi <code>main</code> işlevinden önce de tanımlayabilirsiniz.</p>
<p>İşlevlere daha yakından bakabilmek için cargo new komutu kullanarak projeler dizininde <em>islevler</em> adlı yeni bir proje başlatın. Arkasından <code>başka_işlev</code> örneğini <em>src/main.rs</em>  içine alarak kodunuzu çalıştırın. Ekranınızda aşağıdaki çıktıyı görnelisiniz:</p>
<pre><code class="language-console"> $ cargo run                                                                                                                          ✔
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.67s
     Running `target/debug/islevler`
Merhaba dünya!
Bir başka işlev.
</code></pre>
<p>Satırlar <code>main</code> işlevinde göründüğü sırayla işletilir. İlk olarak &quot;Merhaba dünya!&quot; mesajı, arkasından <code>başka_işlev</code> çağrısının ürettiği &quot;Bir başka işlev.&quot; mesajı yazdırılır. </p>
<h3 id="parametreler"><a class="header" href="#parametreler">Parametreler</a></h3>
<p>İşlevleri, işlev imzasına ait özel değişkenler olan parametreler ile birlikte tanımlayabiliriz. Bir işlevde parametreler bulunuyorsa bu parametrelere somut değerler iletebilirsiniz. İşlevlere parametre olarak iletilen somut değerler argüman aolarak adlandırılır. Fakat insanlar konuşmalarında bu kavramları kullanırken, işlev tanımındaki değişkenleri anlatan <em>parametre</em> yerine argüman, işlev çağrısı esnasında iletilen somut değerleri temsil eden <em>argüman</em> yerine parametre olarak bahsetmekte veya tam tersi biçimde birbirinin yerine geçirerek kullanma eğilimindedirler. </p>
<p>Aşağıda <code>başka_işlev</code>'in şimdiki sürümüne bir parametre ekliyoruz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    başka_işlev(5);
}

fn başka_işlev(x: i32)  {
     println!(&quot;X'in değeri: {}&quot;, x);
}
</code></pre></pre>
<p>Programı çalıştırdığınızda aşağıdaki çıktıyı alıyor olmalısınız:</p>
<pre><code class="language-console">$ cargo run                                                                                                                          ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/islevler`
X'in değeri: 5
</code></pre>
<p>Artık <code>başka_işlev</code>'in <code>x</code> adında ve <code>i32</code> türünde bir parametresi vardır. Bu işleve 5 değeri iletildiğinde <code>println!</code> makrosu bu değeri biçimlendirme dizgisindeki süslü parentezlerin olduğu yere koyar.</p>
<p>İşlev imzalarında bulunan her parametrenin türü <em>mutlaka</em> bildirilmelidir. Bu Rust tasarlanırken alınan bilinçli bir karardır. İşlev  tanımlarında tür bildirimi zorunluluğu, derleyicinin kullanılacak türü kodun başka bir yerinde kullanılmadan anlamasını sağlar.</p>
<p>Tanımlanan parametre sayısı birden fazlaysa bildirimlerin arası aşağıdaki gibi virgül ile ayrılmalıdır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    etiket_değerlerini_yazdır(5, 'h');
}

fn etiket_değerlerini_yazdır(değer: i32, birim: char) {
    println!(&quot;Etiket değerleri: {}{}&quot;, değer, birim);
}
</code></pre></pre>
<p>Bu örnek iki parametresi bulunan <code>etiket_değerlerini_yazdır</code> adlında bir işlev oluşturur. İşlevin <code>değer</code> adındaki ilk parametresi <code>i32</code>, <code>birim</code> adındaki ikinci parametresiyse <code>char</code> türündedir. Bu işlev <code>değer</code> ve <code>birim</code> verilerini içeren bir metin yazdırır. </p>
<p>Bu kodu islevler adlı projenizin <em>src/main.rs</em> dosyasında bulunan bir önceki kodla değiştirdikten sonra <code>cargo run</code> komutunu kullanarak çalıştırın:</p>
<pre><code class="language-console">$ cargo run                                                                                                      ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/islevler`
Etiket değerleri: 5h
</code></pre>
<p>İşlevi <code>değer</code> verisi için <code>5</code>, <code>birim</code> verisi için <code>h</code> ile çağırdığımızdan dolayı program çıktısı bu değerleri içermektedir. </p>
<h3 id="deyimler-ve-İfadeler"><a class="header" href="#deyimler-ve-İfadeler">Deyimler ve İfadeler</a></h3>
<!-- 
Ç.N: 
Statement: değerli ifade anlamında 
Expression: emire daha yakın ifade anlamında
statementler değer taşırken expression bir iş yapar.
-->
<p>İşlev gövdeleri isteğe bağlı olarak bir ifadeyle biten deyimlerden oluşur. Her ne kadar şu ana kadar gördüğünüz işlevler bitiş ifadesi içermiyor olsa da deyimin bir parçası olan ifadeyle karşılaştınız. Rust ifade tabanlı bir dil olduğundan bu ayrıntının anlaşılması önemlidir. Bu ayrım diğer dillerde olmadığından deyim ve ifadenin ne olduğuna ve farklarının işlev gövdelerini nasıl etkilediğini inceleyelim.</p>
<p><em>Deyimler</em> bazı eylemleri gerçekleştiren ve bir değer döndürmeyen talimatlarken, <em>ifadeler</em> sonuç olarak bir değer döndürürler. </p>
<p>Zaten deyim ve ifadeleri daha önce kullanmıştık. Örneğin <code>let</code> anahtar sözcüğüyle değişken oluşturarak ona değer atamak ve Örnek 3-1'deki <code>let y = 6</code> talimatı birer deyimdir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption"> Örnek 3-1: Deyimden içeren bir <code>main</code> işlevi</span></p>
<p>Tıpkı bu örneğin tamamı gibi işlev tanımları da kendi içinde birer deyimdir.</p>
<p>Aşağıdaki kodda yapıldığı gibi <code>let</code> deyimini bir başka değişkene atamaya kalktığınızda, deyimler değer döndürmedikllerinden hata almanız kaçınılmazdır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>Bu programı çalıştırdığınızda aşağıdaki gibi bir hata alacaksınız:</p>
<pre><code class="language-console">cargo run                                                                                                                          ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
error: expected expression, found statement (`let`)
  --&gt; src/main.rs:41:14
   |
41 |     let x = (let y = 6);
   |              ^^^^^^^^^
   |
   = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are experimental
  --&gt; src/main.rs:41:14
   |
41 |     let x = (let y = 6);
   |              ^^^^^^^^^
   |
   = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
   = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

warning: unnecessary parentheses around assigned value
  --&gt; src/main.rs:41:13
   |
41 |     let x = (let y = 6);
   |             ^         ^
   |
   = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
   |
41 -     let x = (let y = 6);
41 +     let x = let y = 6;
   | 

For more information about this error, try `rustc --explain E0658`.
warning: `islevler` (bin &quot;islevler&quot;) generated 1 warning
error: could not compile `islevler` due to 2 previous errors; 1 warning emitted
</code></pre>
<p>Burada <code>let y = 6</code> deyimi bir değer döndürmeyeceğinden <code>x</code>'in bağlanacağı bir değer yoktur. Bu durum böyle bir atamanın atanan değeri döndürdüğü C ve Ruby gibi dillerden farklıdır. Bahsedilen dillerde <code>x = y = 6</code> şeklide bir talimatla hem <code>x</code> hem de <code>y</code> değişkenlerine <code>6</code> değerini atayabilirsiniz. Ancak Rust'ta durum böyle değildir.</p>
<p>İfadeler ise değer olarak hesaplanır ve Rust'ta yazacağınız kodların çoğunluğu ifadelerden oluşacaktır. Bunu <code>11</code> sonucunu veren <code>5 + 6</code> matematiksel işlemiymiş gibi düşünün. İfadeler deyimlerin bir parçası olabilir. Örnek 3-1'de yer alan <code>let y = 6</code> deyimindeki <code>6</code>'nın, işletildiğinde <code>6</code> olarak değerlendirilmesi gibi işlev çağrıları da birer ifadedir. Tıpkı makro çağrılarının birer ifade olması gibi süslü parantezlerle oluşturulan kapsam blokları da birer ifadedir. Örneğin: </p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;Y'nin değeri: {}&quot;, y);
}
</code></pre></pre>
<p>Burada:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p><code>let</code> deyiminin parçası olan ve <code>4</code> olarak değerlendirilen blok bir ifadedir. Bu değer <code>let</code> deyiminin bir parçası olduğundan <code>y</code> değişkenine bağlanır. Şimdiye kadar gördüğünüz çoğu satırın aksine <code>x + 1</code> satırının sonunda noktalı virgülün olmadığına dikkat edin. İfadeler noktalı virgül ile sonlanmaz. Eğer bu ifadenin sonuna noktalı virgül eklerseniz onu değer döndürmeyen bir deyime dönüştürürsünüz. Bunu, bir sonraki konuda dönüş değerleri ve ifadeleri incelerken aklınızda bulundurun.</p>
<h3 id="değer-döndüren-İşlevler"><a class="header" href="#değer-döndüren-İşlevler">Değer Döndüren İşlevler</a></h3>
<p>İşlevler kendilerini çağıran koda değer döndürebilirler. Dönüş değerleri isimlendilmez fakat türleri bir oku (<code>-&gt;</code>) takiben bildirilir. Rust'ta işlevin dönüş değeri, işlev gövdesindeki son ifadenin değeriyle aynıdır. İşlevden erken çıkabilmek için dönüş değeri eşliğinde <code>return</code> anahtar sözcüğünü kullanabilirsiniz, ancak pekçok işlev son ifadeyi örtük biçimde döndürür. Aşağıda değer döndüren bir işlev örneği verilmektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn beş() -&gt; i32 {
    5
}

fn main() {
    let x = beş();

    println!(&quot;X'in değeri: {}&quot;, x);
}
</code></pre></pre>
<p><code>Beş</code> işlevinde <code>5</code> rakamı hariç hiçbir işlev çağrısı, makro ve <code>let</code> deyimi yoktur. Ve bu Rust'ta tamamen geçerli bir işlevdir. İşlev dönüş türünün <code>-&gt; i32</code> olarak belirtildiğine dikkat edin. Bu kodu çalıştırdığınızda aşağıdaki gibi çıktı üretmelidir:</p>
<pre><code class="language-console">$ cargo run                                                                                                                          ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
    Finished dev [unoptimized + debuginfo] target(s) in 1.25s
     Running `target/debug/islevler`
X'in değeri: 5
</code></pre>
<p>İşlevin dönüş değeri <code>5</code> olduğundan dönüş türü de <code>i32</code> olarak ayarlanmıştır. İşlevi dikkatle incelediğimizde iki şeyle karşılaşırız. İlki olarak <code>let x = beş();</code> satırı, <code>x</code> değişkenini başlatmak için işlevin dönüş değerinden yararlandığımızı anlatır. <code>Beş</code> işlevi <code>5</code> değerini döndürdüğünden o satır aşağıdakiyle aynı anlama gelir.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>İkinci olarak, <code>beş</code> işlevi parametresiz olmamasına rağmen döndürülecek değerin türünü tanımlar. Bununla birlikte işlev gövdesi döndürmek istediğimiz değeri ifade ettiğinden noktalı virgül olmadan tek bir <code>5</code>'ten oluşur.</p>
<p>Başka bir örneği inceleyelim:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = artı_bir(5);

    println!(&quot;X'in değeri: {}&quot;, x);
}

fn artı_bir(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Bu kodu çalıştırdığınızda <code>X'in değeri: 6</code> sonucunu yazdıracaktır. Ama <code>x + 1</code>'in bulunduğu satır sonuna onu bir ifadeden deyime çeviren noktalı virgül eklerseniz hata ile karşılaşırsınız:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = artı_bir(5);

    println!(&quot;X'in değeri: {}&quot;, x);
}

fn artı_bir(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Bu kod derlendiğinde aşağıdaki benzer şekilde hata üretecektir:</p>
<pre><code class="language-console">$ cargo run                                                                                                                          ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
error[E0308]: mismatched types
  --&gt; src/main.rs:84:24
   |
84 | fn artı_bir(x: i32) -&gt; i32 {
   |    --------            ^^^ expected `i32`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
85 |     x + 1;
   |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
</code></pre>
<p>Hatayı özetleyen “mismatched types” (uyumsuz türler) mesajı bize bu kodunun temel sorununu göstermektedir. <code>artı_bir</code> işlev tanımı <code>i32</code> türünde bir değer döndürüleceğini bildirirken artık bir deyim olan ve birim türü <code>()</code> olarak temsil edilen satır bir değer olarak değerlendirilemez. Bu nedenle işlev tanımıyla çelişen ve bir hatayla sonuçlabilecek hiçbir şey döndürülmez. Rust hata raporunda noktalı virgülün kaldırılmasını öneren bir mesajla sorunun çözülmesine yardım eder.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-02-data-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch03-04-comments.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-02-data-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch03-04-comments.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
