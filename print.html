<!DOCTYPE HTML>
<html lang="tr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Progamlama Dili Türkçe Çevirisi-2021</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Önsöz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Giriş</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Kurulum</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Bir Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Ortak Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişkenlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> İşlevler</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorumlar</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Mülkiyeti Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Mülkiyet Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Borçlanma</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlişkili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklemek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Sözdizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enum'lar ve Örüntü Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Bir Enum Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Kontrol Akışı Yapısı match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Özgün Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Sandıklar ve Modüller ile Yönetmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Sandıklar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Kapsam ve Gizlilik Kontrolü İçin Modül Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki Bir Öğeye Başvurmanın Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Anahtar Kelimesi ile Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Ortak Koleksiyonlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Değer Listelerini Vektör Kullanarak Depolamak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 Kodlu Metinleri Dizgilerle Saklamak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlere Sahip Anahtarları Eşleme Haritalarında Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamaz Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Türler, Özellikler ve Yaşam Süreleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Özellikler: Paylaşılan Davranışı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referansları Yaşam Süreleri ile  Doğrulamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatik Testler Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır?</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştırılacağını Denetlemek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir I/O Projesi: Komut Satırı Programı Oluşturmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Kabul Etmek</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Bir Dosyayı Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerlik ve Hata Yönetimini Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphane İşlevselliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenleriyle Çalışmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı Yerine Standart Hataya Yazmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> İşlevsel Dil Özellikleri: Yineleyiciler ve Kapamalar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapamalar: Ortam Değişkenlerini Yakalayabilen İsimsiz İşlevler</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyiciler ile Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performansı Karşılaştırmak: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazlası</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Derlemeleri Sürüm Profilleriyle Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Bir Sandığı Crates.io Üzerinde Yayınlamak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Crates.io Üzerindeki İkili Sandıkları cargo install Komutuyla Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo Olanaklarını Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Veriler İçin Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref Özelliğiyle Normal Referanslarmış Gibi Davranmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Temizlik Amaçlı Kod Çalıştırmak İçin Drop Özelliğini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Referans Sayılan Akıllı İşaretçi: Rc&lt;T&gt;</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişkenlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Çevrimleri Bellek Sızıntısına Yol Açabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Mesajlaşma Yardımıyla Eş Zamanlı Programlama</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşılan Durum Eşzamanlılığı</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync and Send Özellikleri ile Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'ın Nesne Yönelimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türden Değerlere İzin Veren Özellik Nesnelerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesne Yönelimli Tasarım Modeli Uygulamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Örüntüler ve Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Örüntüler Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Çürütülebilirlik: Bir Örüntünün Eşleşmeme İhtimali</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Örüntü Sözdizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Kullanım</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Özellikler</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelişmiş Kapamalar ve İşlevler</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Son Proje: Çok İş Parçacıklı Bir Web Sunucusu Oluşturmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Bir Web Sunucusu Oluşturmak</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok İş Parçacıklı Bir Sunucuya Dönüştürmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Sorunsuzca Kapatmak ve Temizlik</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Ekler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Kelimeler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - İşleçler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Özellikler</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Faydalı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitabın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust Nasıl “Nightly Rust” Yapılır? </a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Progamlama Dili Türkçe Çevirisi-2021</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-programlama-dili"><a class="header" href="#rust-programlama-dili">Rust Programlama Dili</a></h1>
<p><em>Steve Klabnik ve Carol Nichols'tan, Rust Topluluğu'nun katkılarıyla...</em></p>
<p>Metnin bu sürümü, Rust 1.57 (2021-12-02'de yayınlandı) veya sonraki bir sürümünü kullandığınızı varsayar. Rust'ı yüklemek veya güncellemek için 1. Bölümdeki <a href="ch01-01-installation.html">Kurulum</a> bölümünü ziyaret edebilirsiniz.</p>
<p>Bu kitabın orijinal dildeki çevrimiçi HTML formatı <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a> adresinde, Türkçe sürümü ise <a href="https://rustdili.github.io/">Türkçe HTML</a> adresinde yer almaktadır. Kitabın çevrimdışı çalışan Orijinal dildeki kopyası ise, <code>rustup</code> ile gerçekleştirilen Rust kurulumuyla birlikte gelir. Bu kitabı okumak için terminalinizde <code>rustup docs --book</code> komutunu çalıştırmanız yeterli olacaktır.</p>
<p>Bu kitabın İngilizce yazılmış ve ciltsiz, e-kitap baskısını <a href="https://nostarch.com/rust">No Starch Press</a> adresinden temin edebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Önsöz"><a class="header" href="#Önsöz">Önsöz</a></h1>
<p>Her zaman bu kadar net olmamakla beraber, Rust programlama dili temelde <em>güç katmak</em> ile ilgilidir: Şu an ne tür bir kodla uğraşıyor olursanız olun, Rust size daha ileri gitme, daha önce ulaştığınızdan çok daha geniş bir alan ve çeşitlilikte güvenli program yazma gücü ve olanaklarını sağlar.</p>
<p>Örneğin, bellek yönetimi, veri gösterimi ve eşzamanlılığın düşük düzeyli ayrıntılarıyla ilgilenen &quot;sistem düzeyinde&quot; çalışmayı ele alalım. Programlamanın bu alanı geleneksel olarak gizemli olarak görülmekte ve sadece yıllarını zorunlu olarak onun adı kötüye çıkmış tuzaklarından kaçınmayı öğrenmeye harcayan seçkin birkaç kişi tarafından erişilebilir durumdadır. Ve bu seçkin kişiler dahi kodlarını istismara, çökmeye yahut bozulmaya karşı korumak için dikkatli davranırlar.</p>
<p>Rust, bu tuzaklardan sıyrılıp kodlama serüveniniz boyunca size yardımcı olacak dost canlısı ve şık bir araç seti sağlayarak bu engelleri aşmanıza yardımcı olur. Daha düşük seviyeli kontrole dalması gereken programcılar, bunu Rust ile, geleneksel çökme veya güvenlik açıkları riskini üstlenmeden ve kararsız bir araç zincirinin detaylarını öğrenmek zorunda kalmadan yapabilirler. Daha da güzeli Rust sizin, hız ve bellek kullanımı açısından verimli ve güvenilir kodlara doğallıkla  yönelmenizi sağlayacak şekilde tasarlanmıştır.</p>
<p>Halihazırda düşük seviyeli kodlarla çalışan programcılar, tutku ve heveslerini diri tutmak amacıyla Rust'ı kullanabilirler. Örneğin, Rust'ta paralel işlemler, derleyicinin klasik hataları kolaylıkla yakalamasından dolayı nispeten düşük ust lerinde bulacağınız CLI uygulamaları, web sunucuları ve başka pek çok kod çeşidinin yazılmasını keyifli hale getirecek kadar etkileyici ve ergonomiktir. Rust ile çalışmak, bir alandan diğerine geçiş yapabileceğiniz beceriler geliştirmenize olanak sağlarken; bir web uygulaması yazarak bu dili öğrenebilir, öğrendiklerinizi bir Raspberry Pi üzerinde kolaylıkla uygulayabilirsiniz.</p>
<p>Bu kitap tam olarak Rust kullanıcılarını güçlendirme potansiyeli taşırken, sadece Rust bilginizi değil, bir programcı olarak gelişim ve güveninizi de arttırmayı hedefleyen samimi ve ulaşılabilir bir metindir. Öğrenmeye hazırsanız buyrun başlayalım. Rust topluluğuna hoş geldiniz!</p>
<p>— Nicholas Matsakis ve Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="giriş"><a class="header" href="#giriş">Giriş</a></h1>
<blockquote>
<p>Not: Kitabın bu baskısı <a href="https://nostarch.com/">No Starch Press'teki</a> <a href="https://nostarch.com/rust">Rust Programlama Dili</a> Kitabının İngilizce baskısı ile aynıdır.</p>
</blockquote>
<p>Rust üzerine bir giriş kitabı olan <em>Rust Programlama Dili</em>'ne hoş geldiniz. Rust programlama dili, daha hızlı ve daha güvenilir programlar yazmanıza yardımcı olur. Üst düzey ergonomi ve düşük seviyeli kontrol programlama dili tasarımlarında bir çelişki gibi görünüyor olsa da Rust bu çelişkiye meydan okur. Rust, bir yandan bellek kullanımı gibi geleneksel olarak düşük seviyeli kontrol ile ilişkilendirilen tüm zorlukları ortadan kaldırırken, diğer yandan sağladığı güçlü teknik kapasite ve olağanüstü geliştirici deneyimini dengeleyerek bu ayrıntıları rahatlıkla kontrol etmenizi sağlar.</p>
<h2 id="rust-kimler-İçin"><a class="header" href="#rust-kimler-İçin">Rust Kimler İçin</a></h2>
<p>Rust, çeşitli nedenlerden dolayı pek çok insan için idealdir. Bu insanların ait olduğu önemli üretim gruplardan birkaçına bakalım.</p>
<h3 id="geliştirici-ekipleri"><a class="header" href="#geliştirici-ekipleri">Geliştirici Ekipleri</a></h3>
<p>Rust, sistem programlama bilgileri farklı düzeylerde olan kalabalık geliştirici ekipleri arasında işbirliğini tesis eden verimli bir araç olduğunu kanıtlıyor. Düşük seviyeli kod, pek çok dilde kapsamlı testler ve deneyimli geliştiriciler tarafından, kodun dikkatle incelenmesiyle yakalanabilen çözümü zor hatalara eğilimlidir. Rust derleyicisi, eşzamanlılık hataları dahil bu türden hatalı kodların derlenmesini reddederek adeta bir bekçi rolü oynar. Böylelikle derleyiciyi takımın bir üyesi olarak gören geliştirici ekibi, değerli zamanlarını hataları takip etmek yerine, programın mantığına odaklanarak geçirebilirler.</p>
<p>Rust sistem programlama dünyası için çağdaş geliştirici araçları da sunar:</p>
<ul>
<li>Rust ile birlikte gelen bağımlılık yöneticisi ve derleme aracı olan Cargo, Rust ekosisteminde bağımlılıkları ekleme, derleme ve yönetmeyi sancısız ve tutarlı hale getirir.</li>
<li>Rustfmt ise geliştiriciler arasında tutarlı bir kodlama tarzı oluşturur.</li>
<li>Rust Dil Sunucusu, kod tamamlama ve satır içi hata mesajları için <em>Entegre Geliştirme Ortamı (IDE)</em>  entegrasyonunu destekler.</li>
</ul>
<p>Bunlar ve Rust ekosistemindeki diğer araçları kullanan geliştiriciler, sistem düzeyinde kod yazarken daha üretken olabilirler.</p>
<h3 id="Öğrenciler"><a class="header" href="#Öğrenciler">Öğrenciler</a></h3>
<p>Rust, öğrenciler ve sistem kavramlarını öğrenmekle ilgilenenler için tasarlanmıştır. Pek çok kişi Rust kullanarak işletim sistemleri geliştirme gibi alanları öğrenmiştir. Rust topluluğu oldukça misafirperver olup öğrencilerin sorularını heves ve heyacanla yanıtlamaktan çekinmezler. Bu kitap gibi girişimler aracılığıyla Rust ekipleri, sistem konseptlerini mümkün olduğunca çok kişi için, özellikle de programlamaya yeni başlayanlar için erişebilir hale getirmek istiyorlar.</p>
<h3 id="Şirketler"><a class="header" href="#Şirketler">Şirketler</a></h3>
<p>Büyüklü küçüklü yüzlerce şirket üretimlerinde çeşitli görevler için Rust'ı kullanıyorlar. Bu görevler arasında komut satırı araçları, web hizmetleri, DevOps araçları, gömülü cihazlar, ses, video analizi ve kod dönüştürme, kripto para birimleri, biyoinformatik, arama motorları, IOT uygulamaları, makine öğrenimi ve hatta Firefox web tarayıcısının önemli bölümleri bile bulunmakta.</p>
<h3 id="açık-kaynak-geliştiricileri"><a class="header" href="#açık-kaynak-geliştiricileri">Açık Kaynak Geliştiricileri</a></h3>
<p>Rust, Rust programlama dili, topluluğu, geliştirici araçları ve kütüphanelerinin oluşumuna katkı sağlamak isteyen kişiler içindir. Rust diline katkıda bulunmanızı çok isteriz.</p>
<h3 id="hız-ve-İstikrara-değer-verenler"><a class="header" href="#hız-ve-İstikrara-değer-verenler">Hız ve İstikrara Değer Verenler</a></h3>
<p>Rust, bir dilden hız ve istikrar bekleyenler içindir.
Aslında hız demekle, hem Rust ile oluşturabileceğiniz programların hızını, hem de Rust'ın kodlama sürecinde sağladığı hızı kastediyoruz. Rust'ın derleyici kontrolleri, yeni özellik ekleme ve kodun yeniden düzenlenmesi aşamalarında kararlılık sağlaması onu, benzer denetimlerin olmadığı, geliştiricilerin genellikle değişiklik yapmaktan kaçındıkları programlama dillerinden ayırır. Sıfır maliyetli soyutlamalar, elle yazılmış kodlar gibi hızlı biçimde düşük seviyeli kodlara derlenebilen üst düzey özellikler için çabalayan Rust, güvenle çalışan kodları hızlı çalışan kodlar haline getirmeye çalışır.</p>
<p>Burada bahsedilen büyük ilgi gurupları dışında Rust, değişik konu ve geliştirme alanlarıyla alakalı pekçok kullanıcıya da destek olmayı umuyor. Sonuç olarak Rust'ın hedefi, geliştiricilerin onlarca yıldır verdiği ödünleri, güvenlik, üretkenlik, hız ve kullanılabilirlik sağlayarak ortadan kaldırmaktır. Rust'ın bu olanaklarını deneyerek sizin için yararlı olup olmayacağına karar verin.</p>
<h2 id="bu-kitap-kimler-İçin"><a class="header" href="#bu-kitap-kimler-İçin">Bu Kitap Kimler İçin</a></h2>
<p>Halihazırda bu kitabın içeriği, okuyucusunun herhangi bir programlama dilinde kod yazdığı kabulüne dayanarak hazırlandığından, farklı programlama geçmişlerine sahip geniş bir izleyici kitlesine uygun olarak hazırlanmıştır. Kitapta programlamanın ne olduğu veya nasıl düşünülmesi gerektiği konusuna zaman ayırmadık. Eğer programlama konusunda yeniyseniz, işe programlamaya giriş konusunda yazılmış kitaplardan başlamanızı öneririz.</p>
<h2 id="bu-kitap-nasıl-kullanılır"><a class="header" href="#bu-kitap-nasıl-kullanılır">Bu Kitap Nasıl Kullanılır</a></h2>
<p>Genel olarak bu kitabın baştan sona doğru sırayla okunması amaçlanmıştır. Sonraki bölümler, önceki bölümlerde işlenen kavramlar üzerine inşa edilmektedir. Genellikle önceki bölümlerde etraflıca incelenmeyen konuların ayrıntılarına daha sonraki bölümlerde değinilmektedir. Bu kitapta, kavramsal ve proje olarak ayrılmış iki ayrı kısım bulunmaktadır. Rust hakkındaki bilinmesi gereken konular kavramsal kısımda işlenirken, öğrenilen konuların uygulamalarını proje kısmında gerçekleştireceğiz. Kitabın 2, 12 ve 20. bölümleri proje, diğer bölümler ise kavramsal kısımlarını oluşturmaktadır. </p>
<p>Bölüm 1, Rust'ın nasıl kurulacağını, bir &quot;Merhaba Dünya!&quot; programının nasıl yazılacağını, Rust'ın paket yöneticisi ve yapım aracı olan Cargo'nun nasıl kullanılacağını anlatır. </p>
<p>Bölüm 2, Rust diline uygulamalı giriş olarak tasarlandığından, bu bölümde işlenen yüksek düzeydeki kavramların ayrıntılarına sonraki bölümlerde değinilecektir. Kodlarla hemen haşır neşir olmak isteyenler için bu bölüm kol ve paçaların sıvanacağı yerdir.</p>
<p>Dilerseniz Rust'ın diğer programlama dillerindeki benzer özelliklerini tartıştığımız 3. Bölümü atlayarak, doğrudan Rust'ın mülkiyet sistemini anlatan kitabın 4. Bölümüne geçiş yapabilirsiniz. Eğer tüm ayrıntıları öğrenmek isteyen titiz bir öğrenciyseniz, bir sonraki bölüme geçmeden önce proje kısmı olan 2. Bölümü  atlayarak 3. Bölüme geçebilir, sonrasında öğrendiklerinizi uygulamak üzere yeniden 2. Bölüme dönebilirsiniz.</p>
<p>Bölüm 5, yapılar ve bundan böyle metot olarak adlandıracağımız yapı işlevlerini, Bölüm 6 ise, <code>enum</code>lar (numaralandırmalar), örüntü eşleme ifadeleri (<code>match</code> expressions) ve <code>if let</code> kontrol akış yapılarını içerir. Rust'ta özel türlerinizi oluştururken yapılar ve <code>enum</code>lardan fazlasıyla yararlanacaksınız.</p>
<p>Bölüm 7 ise, kodunuz ve genel uygulama programlama arayüzünü (API) düzenleyebilmek için Rust'ın modül sistemi ve görünürlük kuralları hakkında bilgi verir. </p>
<p>Bölüm 8, vektörler, diziler ve eşleme haritaları (<code>hash maps</code>) gibi standart kütüphane tarafından sağlanan yaygın veri yapılarını anlatır.</p>
<p>Bölüm 9'da ise Rust'ın hata işleme felsefesini ve tekniklerini inceleyeceğiz.</p>
<p>Bölüm 10, farklı türlerin tek bir türmüş gibi davranabileği kodları yazmanıza olanak sağlayan <code>generics</code> veri türleri, özellikler ve yaşam süreleri hakkında ayrıntılı bilgiler içerir.</p>
<p>Bölüm 11 ise, Rust'ın güvenlik garantilerine rağmen program mantığınızın doğru olup olmadığından emin olabilmeniz için gerekli olan testlerle ilgilidir.</p>
<p>Bölüm 12'de, metni dosyalarda arayan <code>grep</code> komut satırı aracından bir işlev alt kümesi oluşturarak, önceki bölümlerde öğrendiğimiz çoğu kavramı kullanarak bilgilerimizi pekiştirmeye çalışacağız.</p>
<p>Bölüm 13, Rust'ın işlevsel programlama dillerinden esinlendiği özellikler olan kapamalar ve yineleyicilere odaklanıyor. </p>
<p>Bölüm 14'te, Cargo'yu derinlemesine inceleyecek, kendi kütüphanelerinizi başkalarıyla paylaşmanın en iyi yollarından bahsedeceğiz. </p>
<p>Bölüm 15, standart kütüphanenin sunduğu akıllı işaretçileri ve bu işaretçilerin işlevselliğini sağlayan özellikleri anlatır.</p>
<p>Bölüm 16'da, eşzamanlı programlamanın çeşitli modellerini inceleyecek ve Rust'ın paralel görevleri çok sayıda iş parçacığına nasıl korkusuzca dağıtmamıza yardım ettiğini konuşacağız.</p>
<p>Bölüm 17, Rust deyimlerini aşina olduğunuz nesne yönelimli programlama ilkeleriyle karşılaştırır.</p>
<p>Bölüm 18, Rust programlarında fikirleri ifade etmenin güçlü birer yolu olan örüntüler ve örüntü eşleştirme üzerine bir başvuru kaynağıdır.</p>
<p>Bölüm 19, Güvenli olmayan Rust kodları, makrolar, yaşam süreleri, özellikler, türler, işlevler, ve kapamalar hakkında fazladan ayrıntılar gibi bir dizi ilginç ve gelişmiş konuları içerir.</p>
<p>Bölüm 20'de, eşzamanlı çoklu görevleri düşük seviyede bir program olarak çalıştıran web sunucusu projesini bitireceğiz.</p>
<p>Son olarak dil hakkında başvuru niteliğinde yararlı bilgiler içeren bazı ekler aşağıda listelenmektedir.
Ek A, Rust'ın anahtar kelimelerini içerir.
Ek B, Rust programlama dilinin işleç ve sembollerine yer verir.
Ek C, Standart kütüphanenin sağladığı türetilebilir özellikleri kapsar.
Ek D, Bazı faydalı geliştirme araçlarına atıfta bulunur.
Ek E'de ise, Rust'ın sürümlerine yer verilmektedir.</p>
<p>Öğrenim sürenizce kitabın bazı bölümleri atlamak isterseniz, bunun kitabı yanlış okuduğunuz anlamına gelmediğini bilin ve bunu yapmaktan çekinmeyin. Herhangi bir güçlükle karşılaştığınızda önceki bölümlere dönmeniz gerekse bile size uygun olan öğrenim yolunu uygulamaktan çekinmeyin.</p>
<p>Rust öğrenme sürecinin önemli bir parçası, derleyicinin görüntülediği hata mesajlarının nasıl okunacağını öğrenmektir. Bu mesajlar sizi doğru koda yönlendireceğinden, pekçok hata senaryosunu içeren derlenmeyen örnekler vereceğiz. Rastgele bir örneği kopyalayıp çalıştırır ve bir hata alırsanız bunun hata gösterimi olup olmadığını anlamak için ilişkili metni okuduğunuzdan emin olun. Maskotumuz Ferris'i dikkatle takip ederseniz, çalışmaması gereken kodları kolayca anlayabilirsiniz. </p>
<table><thead><tr><th>Ferris</th><th>Anlamı</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>Bu kod derlenmez!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>Bu kod panik üretir!</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>Bu kod bloğu güvenli olmayan kod içerir.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>Bu kod beklenen davranışı üretmiyor.</td></tr>
</tbody></table>
<p>Çoğu durumda, hangi kod sürümünün çalışması gerektiğine dair sizi yönlendireceğiz.</p>
<h2 id="kaynak-kodu"><a class="header" href="#kaynak-kodu">Kaynak Kodu</a></h2>
<p>Bu kitabın oluşmasını sağlayan kaynak kodlara [GitHub][kitap]</p>
<p>[kitap]: https://github.com/RustDili/rust-book-tr/tree/main/TURKISH/src üzerinden ulaşabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="başlarken"><a class="header" href="#başlarken">Başlarken</a></h1>
<p>Öğrenilecek çok şey olmasına rağmen &quot;Her yolculuk bir başlangıç noktasından başlar&quot; diyerek Rust yolculuğumuzu başlatalım. Bu bölümde aşağıdaki konuları tartışacağız:</p>
<ul>
<li>Rust'ı Linux, macOS ve Windows işletim sistemlerine yüklemek.</li>
<li>Ekrana <code>Merhaba Dünya</code> çıktısı basan ilk Rust programını yazmak.</li>
<li>Rust'ın paket yöneticisi ve derleme sistemi olan <code>Cargo</code>'yu kullanmak.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kurulum"><a class="header" href="#kurulum">Kurulum</a></h2>
<p>İlk adımımız Rust'ı kurmak olacağından Rust sürümlerini ve bunlarla ilişkili araçları yönetmek için tasarlanmış bir komut satırı aracı olan <code>rustup</code> aracılığıyla Rust'ı indireceğiz. İndirme işlemini gerçekleştirebilmek için internet bağlantısına ihtiyacınız olacak.</p>
<blockquote>
<p>Herhangi bir nedenle <code>rustup</code> aracını kullanmak istemiyorsanız
diğer seçenekler için lütfen <a href="https://www.rust-lang.org/tools/install">kurulum sayfasını</a> inceleyiniz.</p>
</blockquote>
<p>Aşağıdaki adımlar Rust derleyicisinin en son kararlı sürümünü yükleyecektir. Rust'ın kararlılık garantileri kitapta derlenen örneklerin, Rust'ın daha yeni sürümleriyle de derlenmeye devam etmesini sağlar. Rust'ın hata mesaj ve uyarılarını sürekli iyileştirmesinden dolayı, derleyici çıktıları sürümden sürüme farklılık gösterebilir. Kurulum adımlarına uyarak yüklediğiniz daha yeni ve kararlı Rust sürümleri, beklendiği gibi bu kitabın içeriğiyle uyumlu çalışacaktır.</p>
<blockquote>
<h3 id="komut-satırı-gösterimi"><a class="header" href="#komut-satırı-gösterimi">Komut Satırı Gösterimi</a></h3>
<p>Bu bölümde ve kitap boyunca, terminalde kullanılan bazı komutları göstereceğiz.
Bir terminale girmeniz gereken satırların her biri <code>$</code> karakteri ile başlar.
Ancak bu karakter her komutun başlangıcını gösterdiğinden ayrıca elle yazılmasına gerek yoktur.
<code>$</code> karakteri ile başlamayan satırlar genellikle önceki komutun çıktısını gösterir.
Buna ek olarak PowerShell'e özgü örneklerde <code>$</code> yerine <code>&gt;</code> karakteri kullanılır.</p>
</blockquote>
<h3 id="linux-veya-macos-İçin-rustup-kurulumu"><a class="header" href="#linux-veya-macos-İçin-rustup-kurulumu">Linux veya macOS İçin <code>rustup</code> Kurulumu</a></h3>
<p>Rust'ı Linux veya macOS bir sistemde kullanacaksanız bir terminal açarak aşağıdaki komutu giriniz:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Bu komut bir betik dosyasını indirerek Rust'ın en son kararlı sürümünü sisteminize yükleyecek olan <code>rustup</code> aracının kurulumunu başlatır. Kurulum esnasında sistem şifrenizi girmeniz istenebilir. Kurulumunuz başarılı olduğu takdirde işlem sonunda aşağıdaki satır görünecektir.</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Ek olarak muhtemelen daha önceden sisteminize yüklenmiş olan ve derlenmiş çıktıları tek bir dosyada birlerştirmek amacıyla kullandığı bir tür bağlayıcıya ihtiyacınız olacak. Eğer bir Rust programını derlemeye çalışırken bir bağlayıcının çalıştırılamadığını bildiren hatalar alıyorsanız bu, gerekli olan bağlayıcının sisteminizde yüklü olmadığını ve elle yüklemeniz gerektiği anlamına gelir. C derleyicileri genellikle doğru bağlayıcılarla birlikte gelir. C derleyicisinin kurulumunu öğrenmek için platformunuzun belgelerine göz atmanız gerekir. Ayrıca, bazı yaygın Rust paketleri C kodlarına bağımlı olduğundan bir C derleyicisine ihtiyaç duyacaktır. Bu nedenle şimdiden bir C derleyicisi edinmeniz yararlı olabilir.</p>
<p>macOS için bir C derleyicisini aşağıdaki komutu çalıştırarak alabilirsiniz:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Linux kullanıcıları ise dağıtım belgelerine uygun olarak GCC veya Clang kurmalıdır. Örneğin, eğer Ubuntu kullanıyorsanız <code>build-essential</code> paketini yükleyebilirsiniz.</p>
<h3 id="windows-İçin-rustup-kurulumu"><a class="header" href="#windows-İçin-rustup-kurulumu">Windows İçin <code>rustup</code> Kurulumu</a></h3>
<p>Rust'ı Windows işletim sisteminize kurabilmeniz için <a href="https://www.rust-lang.org/tools/install">Windows için yükle</a> adresine giderek yükleme talimatlarını uygulamanız gerekir. Kurulumun bir aşamasında Visual Studio 2013 veya sonrası için C++ derleme araçlarına da ihtiyacınız olacağını bildiren bir mesaj alacaksınız. Derleme araçlarını edinmenin en kolay yolu <a href="https://visualstudio.microsoft.com/tr/visual-cpp-build-tools/">Visual Studio 2019 için Derleme Araçları</a>'nı yüklemektir. Bu yükleme esnasında yüklenecek bileşenleri seçmeniz istendiğinde &quot;C++ Derleme Araçları&quot;nı seçtiğinizden ve Windows 10 SDK ile ingilizce dil paketi bileşenlerinin dahil edildiğinden emin olun.</p>
<p>Bu kitabın geri kalanı, hem <em>cmd.exe</em> hem de PowerShell'de çalışan komutları kullanır. Bunların arasında belirgin farklılıklar olması durumunda hangisinin kullanılacağını size açıkça belirteceğiz.</p>
<h3 id="güncelleme-ve-kaldırma"><a class="header" href="#güncelleme-ve-kaldırma">Güncelleme ve Kaldırma</a></h3>
<p><code>rustup</code> aracılığıyla kurduğunuz Rust'ı en son sürümüne kolaylıkla güncelleyebilirsiniz. Bunun için terminalinizde aşağıdaki komut satırını çalıştırmanız yeterlidir:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Eğer Rust ve <code>rustup</code> aracını kaldırmak isterseniz terminalinizde aşağıdaki satırı çalıştırmanız yeterlidir.</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="sorun-giderme"><a class="header" href="#sorun-giderme">Sorun Giderme</a></h3>
<p>Rust'ın sisteminize doğru şekilde kurulup kurulmadığını kontrol etmek için terminalinizde aşağıdaki satırı çalıştırabilirsiniz:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Terminalinizde Rust'ın son kararlı sürümün numarasını, kayıt değeri ve işlem tarihini aşağıdaki biçimde görmelisiniz:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Gördüğünüz bilgiler bu biçimdeyse Rust'ı başarıyla yüklemişsiniz demektir. Eğer Windows kullanıyor ve bu çıktıyı göremiyorsanız Rust'ın <code>%PATH%</code> sistem değişkeninizde olup olmadığını kontrol etmelisiniz. Bunların her biri doğru uygulanmış, yerli yerindeyse ve Rust halen çalışmıyorsa yardım alacağınız birkaç yer var. Bunlardan en erişilebilir olanı <a href="https://discord.com/invite/rust-lang">Rust'ın Discord resmi kanalı</a> olan #beginners kanalıdır. Orada size yardımcı olabilecek diğer Rustaceans'larla (evet kendimizi bu saçma isimle adlandırıyoruz) çevrimiçi sohbet edip sorununuza çözüm bulabilirsiniz. Diğer harika kaynaklar arasında ise <a href="https://users.rust-lang.org/">Rust Kullanıcıları Forumu</a> ile <a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a> bulunmaktadır.</p>
<h3 id="yerel-belgeler"><a class="header" href="#yerel-belgeler">Yerel Belgeler</a></h3>
<p>Rust kurulumu, çevrim dışı okuyabilmeniz için Rust belgelerinin yerel bir kopyasını da içerir. Bu yerel belgeleri tarayıcınızda okuyabilmek için terminalinizde <code>rustup doc</code> komutunu çalıştırmanız yeterlidir.</p>
<p>Standart kütüphane tarafından sağlanan bir tür veya işlev hakkında bilgi almak ve nasıl kullanılacağını öğrenmek istiyorsanız uygulama programlama arabirimi (API) belgelerini inceleyebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="merhaba-dünya"><a class="header" href="#merhaba-dünya">Merhaba, Dünya</a></h2>
<p>Artık Rust'ı yüklediğinize göre ilk Rust programımızı yazabiliriz. Yeni bir programlama dilini öğrenme aşamasında <code>Merhaba, dünya!</code> çıktısını ekrana yazdırmak neredeyse gelenek haline geldiğinden biz de burada bu geleneğe uyacağız.</p>
<blockquote>
<p>Not: Bu kitap komut satırı hakkında temel düzeyde bilgi sahibi olduğunuzu varsayar. Bununla birlikte Rust,
kodlarınızı nasıl düzenleyeceğinize, hangi araçları kullanacağınıza veya onları nereye kaydedeceğinize 
karışmadığından, dilerseniz komut satırı yerine aşina olduğunuz veya tercih ettiğiniz entegre 
geliştirme ortamınızı (IDE) kullanabilirsiniz. 
Son zamanlarda Rust ekibi farklı IDE'ler ile entegrasyonu iyileştirmeye odaklandığından artık birçok IDE belli
düzeylerde dil desteği sağlıyor. 
Tercih ettiğiniz IDE'nin yeterli dil desteği sağlayıp sağlamadığını IDE belgelerinden kontrol edebilirsiniz.</p>
</blockquote>
<h3 id="bir-proje-dizini-oluşturmak"><a class="header" href="#bir-proje-dizini-oluşturmak">Bir Proje Dizini Oluşturmak</a></h3>
<p>Öncelikle işe Rust kodlarımızı saklayacağımız bir proje dizini oluşturarak başlayalım. Rust için kodunuzu nerede sakladığınız önemli olmamakla beraber, bu kitapta yer alan alıştırma ve projeler için ana dizininizde (linux için Home)yeni bir <em>projeler</em> dizini oluşturup tüm çalışmalarınızı orada depolamanızı öneririz.</p>
<p>Ana dizinde &quot;Merhaba, dünya&quot; projesinin saklanacağı <em>projeler</em> dizinin oluşturabilmek için bir terminal penceresi açarak sırasıyla aşağıdaki komutları uygulayalım.</p>
<p>Linux, macOS ve Windows PowerShell için aşağıdaki komutları girin:</p>
<pre><code class="language-console">$ mkdir ~/projeler
$ cd ~/projeler
$ mkdir merhaba_dunya
$ cd merhaba_dunya
</code></pre>
<p>Windows CMD içinse şu komutları girin:</p>
<pre><code class="language-console">&gt; mkdir &quot;%USERPROFILE%\projeler&quot;
&gt; cd /d &quot;%USERPROFILE%\projeler&quot;
&gt; mkdir merhaba_dunya
&gt; cd merhaba_dunya
</code></pre>
<h3 id="bir-rust-programı-yazmak-ve-Çalıştırmak"><a class="header" href="#bir-rust-programı-yazmak-ve-Çalıştırmak">Bir Rust Programı Yazmak ve Çalıştırmak</a></h3>
<p>Şimdi yeni bir kaynak dosyası oluşturun ve bunu <em>main.rs</em> olarak isimlendirin. Rust dosyaları daima <code>.rs</code> uzantısıyla sonlanır. Dosyalarınızı birden fazla kelime ile adlandırıyorsanız, bu adları <code>alt_çizgi</code> kullanarak birbirinden ayırın. Örneğin <em>merhabadunya.rs</em> yerine <em>merhaba_dunya.rs</em>'yi teercih edin. </p>
<p>Az önce oluşturduğunuz <em>main.rs</em> dosyasını açarak Örnek 1-1'de yer alan kod satırlarını dosyanıza ekleyin:</p>
<p><span class="filename">Dosya adı: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
	println!(&quot;Merhaba, dünya!&quot;);
}
</code></pre></pre>
<p><span class="caption"> Örnek 1-1: Ekrana &quot;Merhaba, dünya!&quot; yazdıran bir program.</span></p>
<p>Dosyanızı kaydedip terminal penceresine geri dönün. Programımızı Linux veya macOS üzerinde derleyip çalıştırabilmek için aşağıdaki komutları uygulayalım:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Merhaba, dünya!
</code></pre>
<p>Windows kullanıyorsanız <code>./main</code> yerine <code>.\main.exe</code> komutunu kullanmanız gerekir:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Merhaba, dünya!
</code></pre>
<p>Kullandığınız işletim sisteminden bağımsız olarak, terminalinizde <code>Merhaba, dünya!</code> çıktısını görüyor olmalısınız. Bu çıktıyı görmüyorsanız, yardım için kurulum bölümündeki <a href="ch01-01-installation.html#troubleshooting">&quot;Sorun Giderme&quot;</a> başlığına göz atın.</p>
<p>Eğer <code>Merhaba, dünya!</code> satırını görüyorsanız <strong>tebrikler</strong>, bu sizin bir Rust programı yazdığınıza gösterir! Bir programcısı olarak aramıza hoş geldiniz.</p>
<h3 id="bir-rust-programının-anatomisi"><a class="header" href="#bir-rust-programının-anatomisi">Bir Rust Programının Anatomisi</a></h3>
<p>Ekranımıza <code>Merhaba, dünya!</code> yazısını bastıran programda neler olup bittiğine daha yakından bakalım. Bulmacanın ilk parçası aşağıdadır:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
<span class="boring">	println!(&quot;Merhaba, dünya!&quot;);	
</span>
}
</code></pre></pre>
<p>Rust'ta bu satırlar bir işlevi tanımlar. Çalıştırılabilir tüm rust programlarında bulunan <code>main</code> işlevi, programın işletilen ilk kodu olması bakımından özel bir konumdadır. İlk satır parametre almayan ve hiçbir şey döndürmeyen işlev adını <code>main</code> olarak bildirir. Eğer işleve parametre iletecek olsaydık, bu parametreleri <code>()</code> parantezin içine koymamız gerekirdi.</p>
<p>Ayrıca işlev gövdesinin süslü parantezlerle <code>{}</code> sarıldığıba dikkat edin. Rust'ta işlev gövdeleri bu süslü parantezler içine alınmak zorundadır. Girişi gösteren ilk süslü parantezi, işlev bildirimiyle aynı satıra yerleştirip bildirim ile aralarında bir boşluk bırakmak Rust'ın standart yazım biçimidir. </p>
<p>Rust projelerinde standart yazım biçimine bağlı kalmak ve kodlarınızı belirli bir şekilde biçimlendirmek için <code>rustfmt</code> adındaki otomatik biçimlendirme aracını kullanabilirsiniz. Bu araç Rust ekibi tarafından tıpkı <code>rustc</code> gibi standart Rust dağıtımına dahil edildiğinden, halihazırda bilgisayarınızda kurulu olmalıdır. Daha fazla ayrıntı için çevrimiçi belgelere başvurabilirsiniz. </p>
<p>Gövdesi süslü parantezler ile sarmalanmış olan <code>main</code> işlevinin içinde aşağıdaki kod satırı bulunur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>	println!(&quot;Merhaba, dünya!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Bu küçük programdaki tüm işi üstlenerek metni ekrana yazdıran bu satırda dikkat edilmesi gereken dört önemli ayrıntı vardır.</p>
<p>İlki: Rust stili girintilerde bir sekme <em>(tab)</em> yerine dört boşluk <em>(space)</em> kullanılır.</p>
<p>İkincisi: <code>println!</code> terimi bir Rust makrosu çağırır. Eğer burada bir işlev çağrısı yapılıyor olsaydı, <code>println!</code> yerine (<code>!</code> olmadan) <code>println</code>  yazılmış olacaktı. Rust makrolarını 19. bölümde ayrıntılarıyla inceleyeceğiz. Ancak şimdilik <code>!</code> işaretininin normal bir işlev çağrısı değil, işlevler ile aynı kurallara uymayan bir makro çağrısı anlamına geldiğini bilmeniz yeterlidir.</p>
<p>Üçüncüsü: <code>&quot;Merhaba, dünya!&quot;</code> olarak gördüğünüz dizgi, <code>println!</code> makrosuna argüman olarak geçirildiğinde ekrana yazdırılır.</p>
<p>Ve sonuncusu: Satırın noktalı virgül (<code>;</code>) ile bitiyor olması, bu ifadenin bittiğini ve bir sonrakinin başlamaya hazır olduğunu bildirir. Rust kodlarındaki pek çok satır noktalı virgül ile biter.</p>
<h3 id="derlemek-ve-Çalıştırmak-ayrı-birer-adımdır"><a class="header" href="#derlemek-ve-Çalıştırmak-ayrı-birer-adımdır">Derlemek ve Çalıştırmak Ayrı Birer Adımdır</a></h3>
<p>Az önce oluşturduğunuz yeni programınızın çalışma sürecindeki adımlarını incelelim </p>
<p>Bir Rust programı çalıştırılmadan önce Rust derleyicisi kullanılarak ve <code>rustc</code> komutuna aşağıdaki gibi kaynak dosyası adı verilerek derlenmelidir:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>C veya C++ dillerine aşinaysanız, bu işlemin <code>gcc</code> veya <code>clang</code> ile benzeştiğini fark edeceksiniz. Başarıyla gerçekleşen bir derlemenin ardından Rust çalıştırılabilir ikili (binary) bir dosya üretecektir.</p>
<p>Bu çalıştırılabilir dosyaya, Linux, macOS veya Windows PowerShell sistemlerinde, dizin içindeyken terminalinize <code>ls</code> komutu girerek ulaşabilirsiniz. Linux ve macOS sistemlerinde aynı dizinde iki adet dosya görünürken, Windows  PowerShell'de CMD kullanıldığında üç dosya görüntülenecektir.</p>
<pre><code class="language-text">$ ls
main main.rs
</code></pre>
<p>Eğer Windows üzerinde CMD kullanıyorsanız aşağıdaki komutu girmeniz gereklidir:</p>
<pre><code class="language-cmd">&gt; dir /B %= Buradaki /B seçeneği yalnızca dosya isimlerinin görüntülenmesini sağlar =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Her iki durumda da <em>.rs</em> uzantılı bir kaynak kodu dosyası, (windows'ta <em>main.exe</em> olarak ancak diğer platformlarda sadece <em>main</em> olarak görünen) çalıştırılabilir ikili dosya, Windows için ek olarak hata ayıklama bilgilerini içeren <em>.pdb</em> uzantılı birer dosya gösterilecektir.</p>
<p>Bu dizinde çalıştırılabilir halde bulunan <em>main</em> ya da <em>main.exe</em> dosyasını aşağıdaki gibi kullanarak işletebilirsiniz:</p>
<pre><code class="language-console">$ ./main # ya da windows için .\main.exe
</code></pre>
<p>Eğer <code>main.rs</code> dosyanız &quot;Merhaba, dünya!&quot; programınızı içeriyorsa terminalinize <code>&quot;Merhaba, dünya!&quot;</code> metni yazdıracaktır.</p>
<p>Programlama tecrübeniz Ruby, Python veya JavaScript gibi dinamik dillerden oluşuyorsa bu programın ayrı adımlar halinde derleyip çalıştırılmasına alışkın olmayabilirsiniz. Ancak Rust <em>ahead-of-time compiled</em> (öncesinde derlenmiş)  bir dildir. Bu derlenmiş bir Rust programının yürütülebilir dosyasının dağıtılabileceği ve dağıtılan bu dosyanın Rust kurulumuna ihtiyaç duymadan çalıştırılabileceği anlamına gelir. Ancak bir <code>rb, .py</code>, veya <code>.js</code> dosyası dağıttığınızda bu dosyanın kullanılacağı ortamda bir Ruby, Python veya JavaScript uygulamasının yüklü olması gerekir. Bununla birlikte bu dillerden biriyle yazılmış olan bir programı çalıştırabilmek için yalnızca bir komutun kullanılması yeterlidir. Dil tasarımında her şey bir değiş tokuştur.</p>
<p>Her ne kadar basit programların <code>rustc</code> ile derlenmesi yeterliymiş gibi görünse de projeniz büyüdükçe seçeneklerin tümünü yönetmek ve kodun dağıtılmasının kolaylaştırmak isteyeceksiniz. Sonraki bölümde sizi gerçek dünyada daha sık kullanılan ve daha karmaşık Rust programları yazmanıza yardım edecek olacak Cargo aracıyla tanıştıracağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="merhaba-cargo"><a class="header" href="#merhaba-cargo">Merhaba, Cargo</a></h2>
<p>Cargo Rust'ın derleme sistemi ve paket yöneticisidir. Bu araç sizin için; kod oluşturmak, kodun bağımlı olduğu kütüphaneleri <em>kodunuzun ihtiyaç duyduğu kitaplıklara bağımlılık adını veriyoruz)</em> indirmek ve bunları derlemek gibi pek çok görevi yerine getirdiğinden çoğu Rustacean bu aracı Rust projelerini yönetmek için kullanır.</p>
<p>Şu ana kadar yazdığımıza benzeyen basit Rust programları herhangi bir kütüphaneye bağımlı değildir. Bu nedenle &quot;Merhaba dünya!&quot; gibi basit bir proje Cargo ile derlendiğinde, sadece Cargo'nun aracının kod derlemeyi yöneten bölümü kullanılır. Yazılan programlar basitten karmaşığa doğru evrildikçe farklı kütüphanelere olan bağımlılıkları artacağından Cargo aracı bu bağımlılıkların yönetilmesinde size büyük kolaylıklar sağlayacaktır.</p>
<p>Rust projelerinin büyük çoğunluğu Cargo aracını kullandığından, bu kitabın geri kalan bölümlerinde sizin de bu aracı kullandığınız varsayılacaktır. Eğer <a href="ch01-01-installation.html">&quot;Kurulum&quot;</a> bölümünde önerilen resmi yükleyicileri kullandıysanız Rust'la birlikte Cargo aracınız da yüklenmiş olmalıdır. Ancak Rust'ı farklı bir yoldan kurduysanız aşağıdaki kodları terminalinize girerek Cargo'nun sisteminizde kurulu olup olmadığını öğrenebilirsiniz.</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Çıktınızda bir sürüm numarası görüyorsanız bu, Cargo aracının Rust kurulumuyla birlikte yüklendiği anlamına gelir. Eğer <code>Command not found</code> gibi bir hatayla karşılaşıyorsanız Cargo'nun nasıl kurulacağına dair kullandığınız kurulum yöntemi belgelerini incelemelisiniz.</p>
<h3 id="cargo-ile-proje-oluşturmak"><a class="header" href="#cargo-ile-proje-oluşturmak">Cargo ile Proje Oluşturmak</a></h3>
<p>Cargo aracını kullanarak yeni bir proje oluşturup, bu yeni projenin önceki projemiz olan &quot;Merhaba dünya!&quot; ile farklılıklarını incelemeye çalışalım. Başlangıçta açtığımız <em>projeler</em> dizini -ya da kodlarınızı nereye kaydediyorsanız- o dizine geçerek kullandığınız işletim sisteminden bağımsız olarak iş gören aşağıdaki komutları çalıştırın:</p>
<pre><code class="language-console">$ cargo new merhaba_cargo
$ cd merhaba_cargo
</code></pre>
<p>İlk komut, Cargo aracının &quot;merhaba_cargo&quot; adlı yeni bir dizin açmasını ve bu dizinde bir proje için gerekli olan dosyaları oluşturmasını sağlar. </p>
<p>Sonraki komut, Cargo aracının bizim için oluşturduğu dizine atlamamızı sağlar. Dizindeki dosyaları listelerseniz Cargo aracıyla oluşturulan <em>Cargo.toml</em> dosyası ve içinde <em>main.rs</em> dosyasını bulunduran bir <em>src</em> dizini göreceksiniz.</p>
<p>Ek olarak Cargo aracı .gitignore dosyasını içeren yeni bir git deposunun da başlatılmasını sağlar. Eğer <code>cargo new</code> komutunu halihazırda mevcut olan bir git deposu içinde çalıştırırsanız bu git dosyaları oluşturulmaz. Bu davranışı <code>cargo new --vcs=git</code> komutunu kullanarak baskılayabilirsiniz.</p>
<blockquote>
<p>Not: Git yaygın olarak kullanılan bir sürüm kontrol sistemidir. Cargo'yu --vcs bayrağı aracılığıyla farklı bir 
sürüm kontrol sistemi kullanmak ya da sürüm kontrol sistemini kullanmamak üzere ayarlayabilirsiniz. Mevcut 
seçenekleri görmek için <code>cargo new -help</code> komutunu çalıştırabilirsiniz.</p>
</blockquote>
<p>Cargo.toml dosyasını metin düzenleyicinizde açtığınızda içeriği Örnek 1-2'dekine benzer biçimde görünmelidir.</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;merhaba_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<p><span class="caption"> Örnek 1-2: <code>cargo new</code> komutuyla oluşturulan Cargo.toml dosyası içeriği</span></p>
<p>Bu dosya, Cargo'nun yapılandırma formatı olan <a href="https://toml.io/en/">TOML</a>(Tom's Obvious, Minimal Language) biçimindedir.</p>
<p>İlk satırda bildirilen ve altındaki ifadeler tarafından oluşturulan [package] bölüm başlığı, paketin nasıl yapılandırıldığını gösterir. Bu dosyaya daha fazla bilgi ekledikçe, başka bölümler de ekleyeceğiz. </p>
<p>Sonraki üç satır, programınızın Cargo tarafından derlenebilmesi için gereken: İsim, programınızın sürüm bilgisi ve Rust sürümü gibi yapılandırma bilgilerinden oluşur. <code>edition</code> (Rust sürümü) anahtarı konusunu <a href="appendix-05-editions.html">Ek E</a> bölümünde işleyeceğiz.</p>
<p>Son satırda projenizin bağımlılıklarını listelemeye yarayan [dependencies] bölümü yer alır. Rust'ta kodların paketler halinde tutulduğu yapılara <code>crate</code> yani sandık adı verilir. Bu proje için harici bir sandığa ihtiyaç duymayacak fakat 2. Bölümde gerçekleştireceğimiz ilk projede bağımlılıklar bölümünü kullanacağız.</p>
<p>Şimdi <em>src/main.rs</em> dosyasını açalım ve inceleyelim:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
     // &quot;Merhaba, Cargo&quot; olarak değiştirebilirsiniz.
    println!(&quot;Hello, world!&quot;); 
}
</code></pre></pre>
<p>Cargo sizin için tıpkı Örnek 1-1'de olduğu gibi ekranınıza &quot;Merhaba, dünya!&quot; metnini bastıran bir program oluşturdu. Önceki projemiz ile Cargo tarafından üretilen bu proje arasındaki farklar ise, Cargonun projeyi <em>src</em> adlı dizine yerleştirmesi ve üst dizinde ise bir <em>Cargo.toml</em> dosyası yaratması olarak özetlenebilir.</p>
<p>Cargo kaynak dosyalarının <em>src</em> dizininde bulundurulmasını bekler. Projenin ana dizin içeriği, sadece README dosyaları, lisans bilgileri, yapılandırma bilgileri ve kodunuzu ilgilendiren diğer şeyler içindir. Dolayısıyla Cargo, her şeyi ait olduğu dizine yerleştirerek düzenli projeler oluşturmanızı sağlar.</p>
<p>&quot;Merhaba, dünya!&quot; örneğinde yaptığımız gibi Cargo kullanılmadan başlatılan bir projeyi, tıpkı Cargo ile oluşturulmuş gibi düzenleyebilirsiniz. Bunun için proje kaynak kodunu <em>src</em> dizinine taşıyarak, projenin ana dizinde <em>Cargo.toml</em> dosyası oluşturmanız yeterlidir.</p>
<h3 id="bir-cargo-projesini-derleyip-Çalıştırmak"><a class="header" href="#bir-cargo-projesini-derleyip-Çalıştırmak">Bir Cargo Projesini Derleyip Çalıştırmak</a></h3>
<p>Şimdi &quot;Merhaba, dünya!&quot; programını Cargo kullanarak derleyip çalıştırdığımızda oluşan farklılıkları gözlemleyelim. Terminalinizde <em>merhaba_cargo</em> dizinine gelerek aşağıdaki komut yardımıyla projenizi oluşturun: </p>
<pre><code class="language-console">$ cargo build
    Compiling merhaba_cargo v0.1.0 (/home/rusdili/projeler/merhaba_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 1.82s
</code></pre>
<p>Bu komut, <em>target/debug/merhaba_cargo</em> (veya Windows ortamında <em>target\debug\merhaba_cargo.exe</em>) 
konumunda çalıştırılabilir bir dosya oluşturur. Bu dosyayı şu komutla çalıştırabilirsiniz:</p>
<pre><code class="language-console">$ ./target/debug/merhaba_cargo # veya Windows ortamında .\target\debug\merhaba_cargo.exe
Merhaba, Cargo!
</code></pre>
<p>Her şey yolunda giderse terminalinizde &quot;Merhaba, Cargo!&quot; yazısı görünecektir. Cargo uygulamasının ilk kez çalıştırılması projenizin ana dizininde <em>Cargo.lock</em> adında yeni bir dosya oluşturulmasına neden olur. Bu dosya projenizdeki bağımlılıkların tam sürümlerini takip eder. Halihazırda bu proje harici bir kasaya bağımlı olmadığından bu dosya epey boş görünecektir. Bu dosya içeriği Cargo tarafından otomatik olarak yönetildiğinden burada değişiklik yapmanız gerekmez.</p>
<p>Sadece <em>cargo build</em> komutu ile derlediğimiz ve <em>./target/debug/merhaba_cargo</em> komutu ile çalıştırdığımız bu projeyi, aynı anda derleyip çalıştırabilmek için <code>cargo run</code> komutunu kullanabiliriz. </p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/merhaba_cargo`
Merhaba, Cargo!
</code></pre>
<p>Ancak bu defa Cargo'nun, <code>merhaba_cargo</code> programını derlediğini bildiren çıktının gösterilmediğine dikkat edin. Bu durum Cargo'nun kaynak kodun değiştilmediğini bilmesinden kaynaklanır. Kaynak kodunda değişiklik yaptığınmız programı Cargo ile yeniden derleyip çalıştıracak olursanız aşağıdakine benzer bir çıktı görürsünüz:</p>
<pre><code class="language-console">$ cargo run
   Compiling merhaba_cargo v0.1.0 (/home/rusdili/projeler/merhaba_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/merhaba_cargo`
Merhaba, Kargo!
</code></pre>
<p>Yine Cargo tarafından sağlanan ve kodunuzun çalıştırılabilir olup olmadığını denetleyen, fakat çalıştırılabilir dosyasını oluşturmayan <code>cargo check</code> adında bir komut daha vardır:</p>
<pre><code class="language-console">$ cargo check
    Checking merhaba_cargo v0.1.0 (/home/rusdili/projeler/merhaba_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>Bazı durumlarda çalıştırılabilir dosya oluşturmanız gerekmez. <code>cargo check</code> komutu yürütülebilir dosya oluşturma adımını atladığından çoğu zaman <code>cargo build</code> işleminden daha hızlı olacaktır. Geliştirme aşamasında kodunuzun çalışıp çalışmadığını düzenli olarak kontrol ediyorsanız <code>cargo check</code> komutu üretim sürecinizi hızlandıracaktır. Pek çok Rustacean geliştirme aşamasında, programlarının derlendiğinden emin olabilmek için düzenli olarak <code>cargo check</code> kontrolü yapar. Ancak çalıştırılabilir dosyayı kullanmaya hazır olduklarında <code>cargo build</code> komutunu çalıştırırlar. </p>
<p>Cargo hakkında şimdiye kadar öğrendiklerimizi özetleyecek olursak:</p>
<ul>
<li>Bir projeyi derlemek için <code>cargo build</code> komutunu kullanabiliriz.</li>
<li>Bir projeyi tek bir adımla derleyip çalıştırabilmek için <code>cargo run</code> komutunu kullanabiliriz.</li>
<li>Bir projenin hatalarını ikili kod üretmeden derleyerek kontrol edebilmek için  <code>cargo check</code> komutundan yararlanabiliriz.</li>
<li>Cargo, derleme sonucunda oluşturulan çalıştırılabilir ikili dosyayı, kaynak koduyla aynı dizine koymak yerine <em>target/debug</em> dizinine kaydeder.</li>
</ul>
<p>Cargo kullanmanın ek bir avantajı da, hangi işletim sisteminde çalışırsanız çalışın, kullanacağınız komutların değişmiyor olmasıdır. O nedenle bu noktadan itibaren Linux, macOS veya Windows işletim sistemlerinin her biri için ayrı talimatlar vermeyeceğiz.</p>
<h3 id="sürüm-amaçlı-derleme"><a class="header" href="#sürüm-amaçlı-derleme">Sürüm Amaçlı Derleme</a></h3>
<p>Yayına hazır olan projenizi en iyileştirme olanakları ile derleyebilmek için <code>cargo build --release</code> komutunu kullanabilirsiniz. Bu komut çalıştırılabilir dosyanızı <em>target/debug</em> dizini yerine <em>target/release</em> dizinine çıkaracaktır. Fakat en iyileştirmeler, Rust kodlarının daha hızlı çalışmalarını sağlamakla birlikte, programın derlenmesi için gereken süreyi de uzatır. O nedenle en iyileştirme olanaklarında: İlki, hızlı ve sık derleme işlemleri için kullanılan geliştirme profili, diğeriyse tekrar tekrar derlenmeyecek ve çalışır halini olabilecek en kısa sürede kullanıcıya teslim edebileceğiniz nihai programı oluşturan olmak üzere iki farklı profil sunulur.</p>
<p>Eğer kodunuzun çalışma süresini ölçmek istiyorsanız, <em>target/release</em> dizininde bulunan çalıştırılabilir dosyayı <code>cargo build --release</code> komutu ile test ettiğinizden emin olun.</p>
<h3 id="konvansiyonel-cargo"><a class="header" href="#konvansiyonel-cargo">Konvansiyonel Cargo</a></h3>
<p>Cargo basit projelerde rustc kullanımından olduğundan fazla yarar sağlamıyor olsa da geliştirme süreci karmaşıklaştıkça değerini kanıtlayacak bir araç setidir. O nedenle birden çok sandıktan oluşan karmaşık projelerde koordinasyonu Cargo'ya devretmek oldukça faydalıdır.</p>
<p>Her ne kadar <code>merhaba_cargo</code> projesi basit bir projeymiş gibi görünüyor olsa da Rust kariyeriniz boyunca karşılaşacağınız gerçek araçların pek çoğunu kullanıyor. Var olan herhangi bir Rust projesinde çalışırken Git aracılığıyla kodu kontrol etmek, proje dizininine geçip kodu derlemek için aşağıdaki komutları kullanabilirsiniz. </p>
<pre><code class="language-console">$ git clone herhangibirurl.com/herhangibirproje
$ cd herhangibirproje
$ cargo build
</code></pre>
<p>Cargo hakkında daha fazla bilgi edinmek istiyorsanız <a href="https://doc.rust-lang.org/cargo/">Cargo belgelerini</a> inceleyiniz. </p>
<h2 id="Özet"><a class="header" href="#Özet">Özet</a></h2>
<p>Güzel başlayan Rust yolculuğunuzda aşağıdakileri öğrendiniz:</p>
<ul>
<li>Rust'ı, <code>rustup</code> kullanarak en son kararlı sürümüyle yüklemek.</li>
<li>Rust'ı daha yeni bir sürümüne yükseltmek.</li>
<li>Yerel olarak yüklenen belgelere erişmek.</li>
<li>Bir &quot;Merhaba, dünya!&quot; programını yazarak bunu <code>rustc</code> kullanarak doğrudan çalıştırmak.</li>
<li>Yeni bir projeyi Cargo komut ve kurallarını kullanarak derleyip çalıştırmak.</li>
</ul>
<p>Şimdi Rust kodu okuyup yazma becerilerimizi geliştirebilmek için daha sağlam bir program yazmamız gerekiyor. Bu nedenle 2. Bölümde bir tahmin oyunu programı yazacak ve inceleyeceğiz. Eğer öğrenme sürecinize &quot;Ortak Programlama Kavramları&quot;nın nasıl çalıştığını öğrenerek devam etmek istiyorsanız 3. Bölüme ilerleyebilir, ardından 2. Bölüme geri dönebilirsiniz.    </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bir-tahmin-oyunu-programlamak"><a class="header" href="#bir-tahmin-oyunu-programlamak">Bir Tahmin Oyunu Programlamak</a></h1>
<p>Birlikte uygulamalı bir proje üzerinde çalışarak Rust'ı kavramaya çalışalım! Bu bölümde size Rust'ın temel kavramlarından bazıları tanıtılacak ve bu kavramların gerçek bir programda nasıl kullanılacağı gösterilecektir. Bölüm boyunca <code>let</code> ve <code>match</code> anahtar kelimeleri, ilişkili metotlar ve işlevler, harici sandıklar gibi kavramlar üzerinde temel bilgilerinizi uygulayacak ve ilerleyen bölümlerde bu kavramlar ayrıntılarıyla incelenecektir.</p>
<p>Projemizde klasik bir programlama problemi olan sayı tahmin oyununu kodlayacağız. Program 1 ile 100 arasında rastgele bir sayı oluşturacak ve oyuncudan bu sayıyı tahmin etmesini isteyecektir. Oyuncu tahmin ettiği sayıyı girdiğinde bu değer, programın oluşturduğu sayı ile karşılaştırılacak, sayı yüksek veya düşükse bu bilgi oyuncu ile paylaşılarak yeniden tahmin girilmesi istenecek, doğru sayı bulunduğunda bir tebrik mesajı yazdırılarak programdan çıkılacaktır.</p>
<h2 id="yeni-bir-proje-oluşturmak"><a class="header" href="#yeni-bir-proje-oluşturmak">Yeni Bir Proje Oluşturmak</a></h2>
<p>Yeni bir proje oluşturmak için 1. Bölümde oluşturduğumuz <em>projeler</em> dizinine giderek aşağıdaki komutları uygulayın:</p>
<pre><code class="language-console">$ cargo new tahmin_oyunu
$ cd tahmin_oyunu
</code></pre>
<p>İlk satırdaki <code>cargo new</code> komutu argüman olarak projeye verdiğimiz <em>tahmin_oyunu</em> adını alır. İkinci satırdaki <code>cd tahmin_oyunu</code> komutu bizi, Cargo tarafından oluşturulan bu yeni dizine yönlendirir. </p>
<p>Cargo tarafından otomatik oluşturulan <em>Cargo.toml</em> dosyasına göz atalım:</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;tahmin_oyunu&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>Birinci bölümden hatırlayacağınız gibi <code>cargo new</code> komutu size hazır bir &quot;Hello, world!&quot; programı sunar. <code>src/main.rs</code> dosyasını kontrol edelim:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Ve bu programı <code>cargo run</code> komutu kullanarak tek seferde derleyip çalıştıralım:</p>
<pre><code class="language-console">$ cargo run
   Compiling tahmin_oyunu v0.1.0 (/home/rusdili/projeler/tahmin_oyunu)
    Finished dev [unoptimized + debuginfo] target(s) in 1.80s
     Running `target/debug/tahmin_oyunu`
Hello, world!
</code></pre>
<p>Sıklıkla kullanılan <code>run</code> komutu, bir projeyi çabucak derleyip çalıştırmamız ve bir sonraki derleme adımına hızlıca gitmemiz gerektiğinde oldukça faydalıdır.</p>
<p>Programımızı oluşturacağımız <em>src/main.rs</em> dosyasını yeniden açarak kodlamaya başlayalım!</p>
<h2 id="tahmin-verisinin-İşlenmesi"><a class="header" href="#tahmin-verisinin-İşlenmesi">Tahmin Verisinin İşlenmesi</a></h2>
<p>Tahmin oyununun ilk bölümü, kullanıcılardan tahmin verisi olarak işleyebileceği bir değer girmesini isteyecek ve bu verinin  beklenen biçimde olup olmadığını kontrol edecektir. Oyunun başlaması için oyuncunun bir tahmin değeri girmesine izin verilecektir.  Örnek 2-1'de yer alan kodu <em>src/main.rs</em> dosyasına ekleyelim:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);

    println!(&quot;Tahmininizi girin.&quot;);

    let mut tahmin = String::new();

    io::stdin()
    	.read_line(&amp;mut tahmin)
    	.expect(&quot;Veri okuma hatası!&quot;);

    println!(&quot;Tahmininiz: {}&quot;, tahmin);
}
</code></pre>
<p><span class="caption"> Örnek 2-1: Bu kod kullanıcıdan tahmin verisini alarak ekrana yazdırır.</span></p>
<p>Bu kod fazla bilgi içerdiğinden her satırının ayrı ayrı nceleyelim. Kullanıcı girdisini alarak sonucu çıktıta yazdırabilmek için Rust standart kütüphanesi <code>std</code>'nin bir parçası olan <code>io</code> (input/output) kütüphanesini içe aktarmamız gerekir.</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut tahmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">    	.read_line(&amp;mut tahmin)
</span><span class="boring">    	.expect(&quot;Veri okuma hatası!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininiz: {}&quot;, tahmin);
</span><span class="boring">}
</span></code></pre>
<p>Standart kütüphanede tanımlanmış ve Rust'ın varsayılan olarak her program kapsamına otomatik olarak dahil ettiği bir kaç öğe vardır.</p>
<p>Varsayılan haliyle Rust başlatılan her program kapsamına otomatik olarak birkaç türü dahil eder. <em>prelude</em>  olarak adlandırılan bu setin içindekileri <a href="https://doc.rust-lang.org/std/prelude/index.html">Standart kütüphane belgelerinde</a> bulabilirsiniz.</p>
<p>Eğer kullanmak istediğiniz bir veri türü prelüd bölümünde bulunmuyorsa, bu türü <code>use</code> anahtar sözcüğü kullanarak açıkça kapsam içine almanız gerekir. Uygulamamızda kullandığımız <code>std::io</code> kütüphanesi, kullanıcı girdisini kabul etme yeteneği dahil bir dizi kullanışlı özellikle birlikte gelir.</p>
<p>Birinci bölümden hatırlayacağınız üzere <code>main()</code> işlevi programın giriş noktasını oluşturur.</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut tahmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">    	.read_line(&amp;mut tahmin)
</span><span class="boring">    	.expect(&quot;Veri okuma hatası!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininiz: {}&quot;, tahmin);
</span><span class="boring">}
</span></code></pre>
<p><em>Function</em> kelimesinin kısaltılmışı olan <code>fn</code> söz dizimi yeni bir işlev bildirirken, içi boş parantezler <code>()</code> işlevin herhangi bir giriş parametresi almadığını, <em>açılış ayracı</em> olarak da bilinen sağa bakan süslü parantez <code>{</code> ise işlev gövdesinin başlangıç noktasını gösterir.</p>
<p>Yine 1. Bölüm'den hatırlayacağınız üzere <code>println!</code>, bir dizgiyi ekrana yazdırmak amacıyla kullandığımız bir makrodur:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);

    println!(&quot;Tahmininizi girin.&quot;);
<span class="boring">
</span><span class="boring">    let mut tahmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">    	.read_line(&amp;mut tahmin)
</span><span class="boring">    	.expect(&quot;Veri okuma hatası!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininiz: {}&quot;, tahmin);
</span><span class="boring">}
</span></code></pre>
<p>Bu kod oyun hakkında bilgi veren ve kullanıcıdan girdi bekleyen bir komut istemi yazdırır.</p>
<h3 id="değerleri-değişkenlerde-saklamak"><a class="header" href="#değerleri-değişkenlerde-saklamak">Değerleri Değişkenlerde Saklamak</a></h3>
<p>Şimdi aşağıda gösterildiği gibi kullanıcı girdisini depolayacağımız bir değişken oluşturacağız:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span>    let mut tahmin = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">    	.read_line(&amp;mut tahmin)
</span><span class="boring">    	.expect(&quot;Veri okuma hatası!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininiz: {}&quot;, tahmin);
</span><span class="boring">}
</span></code></pre>
<p>Çok şeyin gerçekleştiği bu satırda program ilginçleşmeye başlıyor. Bu satırın <em>değişken</em> oluşturmak için kullanılan bir <code>let</code> ifadesiyle başladığına dikkat edin. İşte size başka bir örnek:</p>
<pre><code class="language-rust ignore">let elmalar = 5;
</code></pre>
<p>Bu satır <code>elmalar</code> adında yeni bir değişken oluşturarak onu <code>5</code> değerine bağlar. Rust'ta değişkenlerin varsayılan olarak değişmez oldukları kabul edilir. Bu kavramı 3. Bölümümüz olan <a href="ch03-01-variables-and-mutability.html#degiskenler-ve-degiskenlik">&quot;Değişkenler ve Değişkenlik&quot;</a><!-- ignore
--> başlığı altında ayrıntılarıyla inceleyeceğiz. Bir değişkeni değiştirilebilir kılmak için  değişken adının önüne <code>mut</code> anahtar kelimesini ekleriz:</p>
<pre><code class="language-rust ignore">let elmalar = 5;    // değişmez
let mut muzlar = 5; // değişebilir
</code></pre>
<blockquote>
<p>Not: <code>//</code> söz dizimi satır sonuna kadar devam eden bir yorumu başlatır. 
Rust'ın derleme aşamasında görmezden geldiği yorum satırlarını <a href="ch03-04-comments.html">3. Bölümde</a><!-- ignore --> tartışacağız.</p>
</blockquote>
<p>Tahmin oyunumuzdaki <code>let mut tahmin</code> söz diziminin, <em>içeriği değiştirilebilir olarak saklanan</em> tahmin adında bir değişken tanımı olduğunu artık biliyorsunuz. Eşittir <code>=</code> işleciyle Rust'a, bu değişkene bir bir şeyler bağlamak istediğinizi bildirmiş olursunuz. 
Eşittir <code>=</code> işlecinin sağ tarafında, yeni bir dizgi örneği almak için kullandığımız <code>String::new()</code> işlevinden dönen ve <code>tahmin</code> değişkeninin bağlandığı değer bulunmaktadır. Dizgiler, UTF-8 baytlarıyla kodlanmış, boyutları değiştirilebilen ve standart kütüphane tarafından sağlanan <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> türündeki metin parçalarıdır.</p>
<p><code>String::new()</code> satırındaki <code>::</code> söz dizimi, <code>new()</code> işlevinin <code>String</code> türünün ilişkili işlevi olduğunu gösterir. İlişkili işlev; türe özgü, o türe ait bir uygulama olduğundan, bu durumda <code>new</code> işlevi yeni ve boş bir dizgi oluşturur. Genellikle <code>new</code> olarak adlandırılan ve ilişkili olduğu türün yeni bir değerini oluşturan bu işlevlerle Rust'ın birçok türünde karşılaşacaksınız.</p>
<p>Özetle <code>let mut tahmin = String::new();</code> satırında bir String türünün yeni ve boş bir örneğiyle ilklendirilen değiştirilebilir bir değişken tanımlanmaktadır.</p>
<h3 id="kullanıcının-girdiği-veriyi-yakalamak"><a class="header" href="#kullanıcının-girdiği-veriyi-yakalamak">Kullanıcının Girdiği Veriyi Yakalamak</a></h3>
<p>Hatırlayacağınız gibi programın ilk satırında <code>use std::io</code> söz dizimini kullanarak Rust standart kütüphanesinden giriş/çıkış işlevselliğini uygulamıştık. Şimdiyse <code>io</code> modülünde bulunan <code>stdin</code> işlevini çağıracağız:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut tahmin = String::new();
</span><span class="boring">
</span>    io::stdin()
    	.read_line(&amp;mut tahmin)
<span class="boring">    	.expect(&quot;Veri okuma hatası!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininiz: {}&quot;, tahmin);
</span><span class="boring">}
</span></code></pre>
<p>Eğer <code>io</code> kütüphanesini programın en başındaki <code>use std::io</code> satırınyla ithal etmemiş olsaydık, <code>stdin</code> işlev çağrısını, kod içinde <code>std::io::stdin</code> şeklinde yazarakta kullanabilirdik. <code>stdin</code> işlevi terminalinizdeki standart girdinin tanıtıcısını temsil eden bir <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore --> tür örneği döndürür.</p>
<p>Sonraki <code>.read_line(&amp;mut tahmin)</code> satırında, kullanıcıdan veri alacak olan standart girdi tanıtıcısındaki <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> metodunu çağırılarak kendisine, girdisinin saklanacağı dizgi olan <code>&amp;mut tahmin</code> argümanı iletilir. <code>read_line</code> metodunun bütün işi, kullanıcı tarafından girilen her veriyi standart girişe almak ve bunları bir dizgi içine yerleştirmektir.Yöntemin, kullanıcı girdisi eklendikçe dizgi içeriğini değiştirilebilmesi için, kendisine iletilen argümanın değişebilir olması gerekmektedir.</p>
<p><code>&amp;</code> belirteci, bu argümanın <em>referans</em> türünden olduğunu bildirdiğinden, kodun bazı bölümleri tarafından bu değişkenlere, bellekte defalarca kopyalanmaları gerekmeksizin erişilmesi sağlanmış olur. Referanslar dilin güçlü ve karmaşık bir özelliğidir.
Rust'ın önemli avantajlarından biri de referans kullanımının kolay ve güvenli olmasıdır. Bu programı bitirebilmeniz için daha fazla ayrıntı bilmenize gerek yok. Şimdilik tıpkı değişkenler gibi referansların da varsayılan olarak değişmez olduklarını ve onları değiştirilebilir kılabilmek için <code>&amp;tahmin</code> yerine <code>&amp;mut tahmin</code> yazmamız  gerektiğini öğrenmemiz yeterlidir. (Referanslar konusu 4.Bölümde ayrıntılı olarak ele alınacaktır.)</p>
<h3 id="result-türünü-kullanarak-olası-hataları-İşlemek"><a class="header" href="#result-türünü-kullanarak-olası-hataları-İşlemek"><code>Result</code> Türünü Kullanarak Olası Hataları İşlemek</a></h3>
<p>İncelememize <code>io::stdin</code> ile başlayan ifadenin üçüncü satırıyla devam edelim. Her ne kadar ayrı bir satırmış gibi görünmesine rağmen, bu satır da tıpkı bir önceki satır gibi, aynı mantıksal kod satırının parçası olup koda <code>expect</code> metodunu eklemektedir:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut tahmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">    	.read_line(&amp;mut tahmin)
</span>    	.expect(&quot;Veri okuma hatası!&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;Tahmininiz: {}&quot;, tahmin);
</span><span class="boring">}
</span></code></pre>
<p>Oysa bu kodu bu şekilde de yazabilirdik:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut tahmin).expect(&quot;Veri okuma hatası!&quot;);
</code></pre>
<p>Fakat böyle uzun satırları okumak zor olduğundan en iyisi onu parçalara ayırmaktır. Bir metodu .yöntem_adı() söz dizimiyle çağırdığınızda, uzun ifadeleri mantıksal parçalara bölebilmeniz için genellikle yeni satırlar ve boşluklar eklemeniz mantıklı olur. 
Şimdi bu satırın ne anlama geldiğini inceleyelim.</p>
<p>Daha önce bahsettiğimiz gibi <code>read_line</code> işlevi, kullanıcı tarafından girilen verileri kendisine ilettiğimiz dizgiye depolarken, bu işin gerçekleştirilmesi sırasında oluşabilecek hataların izlenebilmesi için <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a><!-- ignore --> türünde bir değer döndürür. Rust standart kitaplığı <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> olarak adlandırılan, generic türler ve <code>io::Result</code> gibi alt modüllerle kullanılmak üzere bir tür bulundurur. Varyant olarak bilinen ve sabit olasılık kümelerinden oluşan <a href="ch06-00-enums.html">enums</a><!-- ignore --> türleri genellikle eşleme işlemlerinde kullanılır. Enum kullanan eşleme işlemlerinde değerlendirilen koşul enum değerinin hangi varyantına uyuyorsa kodun o bölümü çalıştırılır. </p>
<p>Hata işleme bilgilerinin kodlanmasını amaçlayan <code>Result</code> türünü 6. Bölümde ayrıntılarıyla ele alacağız.</p>
<p><code>Result</code> türünün <code>Ok</code> ve <code>Err</code> adında iki varyantı bulunur. <code>Ok</code> varyantı, işlem sonucunun başarılı olması durumunda döndürülen değere ev sahipliği yaparken, işlemin başarısız olması anlamına gelen <code>Err</code> varyantında ise bu başarısızlığın nasıl ve neden olduğunu açıklayan bilgiler depolanır.</p>
<p>Herhangi bir türün değerleri için olduğu gibi <code>Result</code> türünün değerleri için de tanımlanmış ilişkili metodlar bulunur. Bu bağlamda<code>io::Result</code> örneğinin de <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a><!-- ignore --> adında bir metodu bulunmaktadır. Bu metot çağrıldığında, <code>io..Result</code> örneği <code>Err</code> değeri taşıyorsa <code>expect</code> programın çökmesine neden olacak ve kendisine argüman olarak ilettiğiniz mesajı görüntüleyecektir. <code>read_line</code> metodunun <code>Err</code> değerini döndürmesi genellikle işletim sisteminden kaynaklanan bir hatadır. Bununla birlikte <code>io::Result</code> örneği <code>Ok</code> değerini taşıyorsa, <code>expect</code> metodu <code>Ok</code> içinde saklanan dönüş değerini alarak kullanmanız için size döndürecektir. Bu durumda döndürülen <code>Ok</code> değeri kullanıcı tarafından standart girdiye iletilen bayt sayısından ibaret olacaktır.</p>
<p>Bu aşamada <code>expect</code> metodunu çağırmasanız bile programınız derlenir fakat aşağıdaki gibi bir uyarı alırsınız:</p>
<pre><code class="language-console">$ cargo run 
   Compiling no-listing-02-without-expect v0.1.0 (/home/rusdili/projeler/tahmin/oyunu)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `no-listing-02-without-expect` (bin &quot;no-listing-02-without-expect&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.86s
</code></pre>
<p>Rust <code>read_line</code> tarafından döndürülen <code>Result</code> değerini kullanmadığınızı ve programın olası bir hatayı işlemediğini bildirmektedir.</p>
<p>Her ne kadar uyarıları bastırmanın doğru yolu bir hata işleyici yazmak olsada, şu aşamada sorun oluştuğunda programın çökmesini istediğimizden <code>expect</code> metodunu kullanmak zorundayız. Hata işlemek konusunu kitabın <a href="ch09-02-recoverable-errors-with-result.html">9. Bölümünde</a><!-- ignore -->.  ayrıntılarıyla inceleyeceğiz.</p>
<h3 id="println-yer-tutucuları-ile-değerleri-yazdırmak"><a class="header" href="#println-yer-tutucuları-ile-değerleri-yazdırmak"><code>Println!</code> Yer Tutucuları ile Değerleri Yazdırmak</a></h3>
<p>Kodun sonlandığı noktayı gösteren <em>kapanış ayracı</em> (sola bakan süslü parantez) haricinde değerlendirilmesi gereken bir satırımız daha var:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut tahmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">    	.read_line(&amp;mut tahmin)
</span><span class="boring">    	.expect(&quot;Veri okuma hatası!&quot;);
</span><span class="boring">
</span>    println!(&quot;Tahmininiz: {}&quot;, tahmin);
<span class="boring">}
</span></code></pre>
<p>Bu satır kullanıcı girdisini kaydettiğimiz dizgiyi ekrana yazdırabilmek için vardır. Yer tutucuları temsil eden süslü parantezleri <code>{}</code> ise bir değerin yerini tutan yengeç kıskaçlarına benzetebilirsiniz. Çok sayıda değerin gösterilmesi amacıyla da kullanabileceğiniz bu parantezlerin ilk çifti, biçimlendirilmiş dizgiden sonraki ilk değeri içerirken, sonraki parantez ikinci değeri, bir sonraki üçüncü değeri gösterecektir. İki farklı değişkenin değerlerini ekrana yazdıran örnek <code>println!</code> çağrısı aşağıdakine benzeyecektir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x değeri = {}, y değeri = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Bu örnek ekrana <code>x değeri = 5, y değeri = 10</code> yazdıracaktır.</p>
<h3 id="İlk-bölümü-test-etmek"><a class="header" href="#İlk-bölümü-test-etmek">İlk Bölümü Test Etmek</a></h3>
<p>Programın ilk bölümünü test etmek için <code>cargo run</code> komutunu çalıştırın:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run                                                   ✔ 
   Compiling tahmin_oyunu v0.1.0 (/home/rusdili/projeler/tahmin_oyunu)
    Finished dev [unoptimized + debuginfo] target(s) in 1.34s
     Running `/home/rusdili/projeler/tahmin_oyunu/target/debug/tahmin_oyunu`
Tuttuğum sayıyı tahmin edin!
Tahmininizi girin.
6
Tahmininiz: 6
</code></pre>
<p>Klavyeden girdi alıp onu ekrana yazdırabildiğimize göre oyunun ilk bölümü tamamlanmış demektir. </p>
<h3 id="gizli-sayıyı-oluşturmak"><a class="header" href="#gizli-sayıyı-oluşturmak">Gizli Sayıyı Oluşturmak</a></h3>
<p>Şimdi kullanıcının tahmin edeceği gizli sayıyı oluşturmamız gerekiyor. Oyunu eğlenceli ve tekrar oynanabilir kılabilmek amacıyla  gizli sayıyı her defasında değiştirmemiz gerekir. Oyunu kolaylaştırmak için de, tahmin edilecek sayıyı 1 ile 100 arasında ve tesadüfi biçimde seçmeliyiz. Rust'ın standart kitaplığı rastgele sayı oluşturabilecek işlevselliği henüz barındırmıyor. Ancak Rust ekibi bu işlevsellik için <a href="https://crates.io/crates/rand"><code>rand</code></a> adlı harici bir sandık sunar.</p>
<h3 id="İlave-İşlevsellik-İçin-sandık-kullanmak"><a class="header" href="#İlave-İşlevsellik-İçin-sandık-kullanmak">İlave İşlevsellik İçin Sandık Kullanmak</a></h3>
<p>Sandık, Rust kaynak kodu dosyalarının bir araya getirilmiş halidir. Geliştirmekte olduğumuz bu proje bile aslında bir çalıştırılabilir <em>ikili sandık</em> (binary crate) sandıktır. Bize harici olarak sunulan <code>rand</code> sandığı başka programlarda kullanılması amaçlanan kodları içeren bir <em>kitaplık sandığı</em>dır.</p>
<p>Harici sandıkların koordinasyonu, <code>Cargo</code> özelliklerinin ışıldadığı yerdir. <code>Rand</code> sandığı kullanan bir kod yazabilmek için önceklikle <em>Cargo.toml</em> dosyasının bu bağımlılığı içerecek şekilde güncellenmesi gerekir. Bunu gerçekleştirebilmek için aşağıdaki satırları, <em>Cargo.toml</em> dosyasında yer alan <code>[dependencies]</code> başlığının altına doğru şekilde ekleyin. Kodun sağlıklı çalışabilmesi için Rand sandığını buradaki gibi aynı sürüm numarasıyla bildirdiğinizden emin olun:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.3&quot;
</code></pre>
<p><code>Cargo.toml</code> dosyasındaki bölüm başlıklarının altına gelen her şey, başka bir bölüm başlayana dek o bölümün parçasıdır. Bağımlılıklar yani <code>[dependencies]</code> bölümünde Cargo'ya, projenizin çalışabilmesi için ihtiyaç duyduğu harici sandıkları ve bu sandıkların hangi sürümlerini kullanacağınızı bildirirsiniz. Bu durumda biz de projemizde kullanacağımız <code>rand</code> sandığı sürümünü <code>0.8.3</code> olarak beldireceğiz. Cargo, sürüm numaralarını bildirmekte standart olarak kullanılan <a href="http://semver.org">anlamsal sürümleme</a><!-- ignore --> sistemini -SemVer olarak da adlandırılır- yorumlamayı bildiğinden, <code>0.8.3</code>'ün aslında <code>^0.8.3</code>'ün kısaltması olduğunu anlar. Bağımlılık olarak bildirdiğimiz <code>rand</code> sandığının sürüm numarası <code>0.8.3</code>, projemizin en az <code>0.8.3</code> olan ancak <code>0.9.0</code>'ın altında kalan herhangi bir sürümle çalışabileceği anlamına gelmektedir. Bu durumda Cargo, <code>0.8.3</code>'den <code>0.9.0</code>'a kadar olan olası sandık sürümlerinin, <code>0.8.3</code> sürümüyle uyumlu genel API'ye sahip olduğunu varsayarak, projemizin derlenebilmesi için gereken en son sürümü ediner ve projemizin çalışmasını sağlar. Bununla birlikte <code>0.9.0</code> veya daha sonraki herhangi bir sürümün aşağıdaki örneklerin kullandığı API ile aynı API'ye sahip olacağı garanti edilmez.</p>
<p>Şimdi herhangi bir kod değişikliği yapmadan Tıpkı Örnek 2-2'de gösterildiği haliyle projeyi oluşturalım.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
  Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
  Compiling rand_core v0.6.2
  Compiling libc v0.2.86
  Compiling getrandom v0.2.2
  Compiling cfg-if v1.0.0
  Compiling ppv-lite86 v0.2.10
  Compiling rand_chacha v0.3.0
  Compiling rand v0.8.3
  Compiling tahmin_oyunu v0.1.0 (/home/rusdili/projeler/tahmin_oyunu)
   Finished dev [unoptimized + debuginfo] target(s) in 0.28s
</code></pre>
<p><span class="caption">Örnek 2-2: Bağımlılık olarak eklenen <code>rand</code> sandığı sonrasında <code>cargo build</code> komutuyla elde edilen çıktı.</span></p>
<p>Derleme esnasında oluşan çıktı işletim sisteminize bağlı olarak değişebileceğinden derlenen paket adları ve sürüm numaraları ekranınızda farklı sırayla yansıtılabilir. Bununla birlikte yüklenen sürümler <em>anlamsal sürümleme</em> sayesinde kodumuzla uyumlu olacaktır.</p>
<p>Harici bir bağımlılık eklediğimizde Cargo, <a href="https://crates.io/">Crates.io</a>'daki verilerin bir kopyası olan <em>kayıt defteri</em>nden, ihtiyaç duyduğumuz tüm bağımlılıkların en son sürümlerini çekecektir. Crates.io, Rust ekosistemindeki geliştiricilerin açık kaynak projelerini başkaları ile paylaşmak amacıyla sandıklar şeklinde yayınladıkları çevrimiçi bir kaynaktır.</p>
<p>Kayıt defteri güncellendikten sonra Cargo, <code>[dependencies]</code> bölümünü kontrol ederek henüz sahip olmadığımız sandıkları indirir. Bağımlılık olarak yalnızca <code>rand</code> kütüphanesi eklense bile, Cargo bu kütüphanenin çalışabilmesi için gerekli diğer sandıkları da indirecektir. Gerekli sandıklar indirildikten sonra Rust önce bu sandıkları derleyecek, arkasından projemizi mevcut bağımlılıklar ile yeniden oluşturacaktır.</p>
<p>Herhangi bir değişiklik yapmadan <code>cargo build</code> komutunu yeniden çalıştırırsanız, uçbiriminizde <code>Finished</code> satırınndan başka çıktı alamazsınız. Bu eylemsizlik Cargo'nun; bağımlılıkların indirilip derlendiğini, kodda değişiklik yapılmadığını ve <em>Cargo.toml</em> dosyasının aynı kaldığını bilmesinden kaynaklanır. Bu durumda yapacak bir şey olmadığını fark eden Cargo programı derlemeden süreci sonlandırır.</p>
<p>Fakat <em>src/main.rs</em> dosyasını açıp üzerinde basit bir değişiklik yaparak kaydedip derlerseniz, yalnızca iki satırdan oluşan aşağıdaki çıktıyla karşılaşırsınız: </p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling tahmin_oyunu v0.1.0 (/home/rusdili/projeler/tahmin_oyunu)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
</code></pre>
<p>Bu satırlar derlemenin sadece <em>src/main.rs</em> dosyasındaki küçük değişiklikler gözetilerek gerçekleştirdildiğini gösterir. Bağımlılıkların değişmediğini ve projenin, önceden indirilip derlenen bağımlılıklarla kullanılmasının mümkün olduğunu anlayan Cargo, kodu sadece değişen kısmıyla yeniden oluşturur.</p>
<h4 id="cargolock-dosyası-ile-yinelenebilir-derlemeler"><a class="header" href="#cargolock-dosyası-ile-yinelenebilir-derlemeler"><code>Cargo.lock</code> Dosyası ile Yinelenebilir Derlemeler</a></h4>
<p>Cargo, siz veya başkaları tarafından kodunuzun her derlenişinde aynı yapıyı yeniden oluşturan bir mekanizmaya sahiptir. Bu Cargo'nun siz aksini söyleyene kadar sadece bildirdiğiniz bağımlılık ve sürümlerini kullanması anlamına gelir. Örneğin <code>rand</code> sandığının yeni sürümü 0.8.4'ün önemli bir hata düzeltmesiyle yakın bir zamanda yeniden yayınlanacağını varsayalım. Bu durumda ne olacağının yanıtı, <code>cargo build</code> komutunu ilk çalıştırdığınızda <em>tahmin_oyunu</em> dizininde oluşturulan <em>Cargo.lock</em> dosyasında bulunmaktadır.</p>
<p>Bir projeyi ilk kez derlediğinizde kriterlere uyan tüm bağımlılık sürümleri Cargo tarafından belirlenerek <em>Cargo.lock</em> dosyasına yazılır. Daha sonra projenin yeniden derlemmesi gerektiğinde Cargo, <em>Cargo.lock</em> dosyasının halihazırda var olduğunu görecek ve tüm sürüm oluşturma işlemlerini yapmak yerine, orada belirtilmiş sürümleri kullanacaktır. Bu sizin otomatik olarak tekrarlanabilir derlemelere sahip olmanızı sağlar. Başka bir ifadeyle, <em>Cargo.lock</em> dosyası sayesinde projeniz siz yeniden ve açıkça yükseltme yapmadığınız sürece <code>0.8.3</code> sürümünde kalmaya devam eder.</p>
<h4 id="bir-sandığı-yeni-bir-sürüme-güncellemek"><a class="header" href="#bir-sandığı-yeni-bir-sürüme-güncellemek">Bir Sandığı Yeni Bir Sürüme Güncellemek</a></h4>
<p>Bir sandığı güncellemek istediğinizde Cargo size, <em>Cargo.lock</em> dosyasını yok sayacak ve <em>Cargo.toml</em> dosyanızdaki kriterlere uygun son sürümleri bulmanızı sağlayacak <code>update</code> adında bir komut daha sağlar. Süreç başarıyla tamamlanırsa güncellenen bu sürümler <em>Cargo.lock</em> dosyasına yazılır. Ancak güncelleme esnasında varsayılan olarak sadece <code>0.8.3</code>'ten büyük <code>0.9.0</code>'dan küçük olan sürümler aranacaktır. Eğer <code>rand</code> sandığı için <code>0.8.4</code> ve <code>0.9.0</code> olmak üzere iki yeni sürüm yayınlanmışsa <code>update</code> komutunu çalıştırdığınızda aşağıdaki gibi bir çıktı görünecektir:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
Cargo'nun yeni sürümümnün 0.8.x olduğunu varsaydığımızda
Diğer türlü burada sunulan varsayımsal çıktıyı elde edebilmek için
Rehber olarak başka bir güncellemeden yararlanın -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
<p>Bu noktada <em>Cargo.lock</em> dosyanızda kullanmakta olduğunuz <code>rand</code> sandığı sürümünün, 0.9.0 sürümünün yok sayılarak <code>0.8.4</code>'e yükseltildiğini belirten değişikliğin yapıldığını fark edeceksiniz. Eğer rand sandığının <code>0.9.0</code> veya <code>0.9.x</code> sürümlerinden birini kullanmak isterseniz, <em>Cargo.toml</em> dosyanızı aşağıdaki şekilde güncellemeniz gerekir:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p><code>cargo build</code> komutunu yeniden çalıştırdığınızda, Cargo mevcut sandıkların kayıtlarını güncelleyerek <code>rand</code> kütüphanesi gereksinimlerini bildirdiğiniz yeni sürüme göre yeniden değerlendirecektir.</p>
<p><a href="http://doc.crates.io">Cargo</a><!-- ignore --> ve <a href="http://doc.crates.io/crates-io.html">Ekosistemi</a><!-- ignore --> hakkında söylenecek çok şey olmasına rağmen bunları, 14. Bölümde enine boyuna tartışacağız. Şimdilik Cargo'nun, kitaplıkların yeniden kullanımını kolaylaştırarak geliştiricilerin, bir dizi paketten oluşan küçük projeler yazabilmelerini sağladığını bilmemiz yeterlidir. </p>
<h3 id="rastgele-sayının-Üretilmesi"><a class="header" href="#rastgele-sayının-Üretilmesi">Rastgele Sayının Üretilmesi</a></h3>
<p>Artık rastgele sayıyı üretebilmek için <code>rand</code> sandığını kullanabiliriz. Yapacağımız ilk şey <em>src/main.rs</em> dosyamızı örnek 2-3'te olduğu gibi güncellemektir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);

    let gizli_sayı = rand::thread_rng().gen_range(1..101);

    println!(&quot;Gizli sayı: {}&quot;, gizli_sayı);

    println!(&quot;Tahmininizi girin.&quot;);

    let mut tahmin = String::new();

    io::stdin()
        .read_line(&amp;mut tahmin)
        .expect(&quot;Veri okuma hatası!&quot;);

    println!(&quot;Tahmininiz: {}&quot;, tahmin);
}
</code></pre>
<p><span class="caption">Örnek 2-3: Rastgele sayı üretmek için eklenen kodlar.</span></p>
<p>Önce projemizin kapsam alanına <code>use rand::Rng</code> şeklinde bir <code>use</code> satırı ekliyoruz. Rand kitaplığının <code>Rng</code> özelliği, rastgele sayı üreteçlerinin uyguladığı metotları tanımladığından, bu yöntemin kullanabilmesi için kütüphanenin kapsama dahil edilmesi gerekir. Özellikler <em>(trait)</em> konusuna 10. Bölümde değineceğiz.</p>
<p>Ardından ilk ekran çıktısını üreten satırdan sonra iki satır daha ekleyeceğiz. Bu satırlardan ilki olan <code>rand::thread_rng()</code> işlevinde, işletim sistemi tarafından başlatılan ve geçerli olan iş parçacığına özgü kullanılan rastgele sayı üreteci başlatılacak ve üretilecek olan sayı <code>ı</code> adlı değişkende saklanacaktır. Bu sayının üretiminde ise <code>rand::Rng</code> olarak kapsama alanına dahil ettiğimiz <code>Rng</code> özelliğinde tanımlanmış <code>gen_range()</code> metodundan yararlanılacaktır. Kendisine verilen bir aralığa göre rasgele sayı üreten <code>gen_range()</code> metodunda kullanılan aralık ifadesi <code>başlangıç..bitiş</code> şeklinde olup, başlangıç olarak verilen alt sınır değeri kapsanmakta, bitiş olarak verilen üst sınır değeri ise hariç tutulmaktadır. Bu nedenle 1 ile 100 arasındaki sayılar arasından birini rastgele olarak talep edebilmemiz için metoda ileteceğimiz aralık değerlerini, aralığa dahil edilecek olan 1 ile aralığa dahil edilmeyecek olan üst sayı sınırını bildiren 101 olarak bildirmemiz gerekir. Eğer bu ifade biçimi size karışık geliyorsa, aynı işi yapan ve hem başlangıç hem de bitiş değerlerini aralığa dahil olarak gösterebileceğiniz <code>1..=100</code> şeklindeki gösterimi <code>gen_range()</code> metoduna aralık olarak iletebilirsiniz.</p>
<blockquote>
<p>Bir sandığın hangi özellik, metot ve işlevlerinin kullanılabileceğini her zaman bilemeyebilirsiniz.
Sandıkların nasıl kullanılması gerektiğine dair talimatlar o sandığa ait belgelerde yer almaktadır.
Cargo'nun bir başka güzel özelliği de, tüm bağımlılıklarınız tarafından sağlanan dökümantasyonu yerel 
olarak oluşturup, tarayıcınızda uyumlu olarak çalıştıracak olan <code>cargo doc --open</code> komutunu sağlamasıdır.
örneğin <code>rand</code> sandığındaki bulunan diğer işlevler hakkında bilgilenmek istiyorsanız, <code>cargo doc --open</code>
komutunu çalıştırarak, sol kenar çubuğunda yer alan <code>rand</code> seçeneğine tıklamanız yeterlidir.</p>
</blockquote>
<p>Eklediğimiz ikinci satır ise <code>gizli_sayı</code> değişkenini yazdırmak için kullanılacaktır. Kodumuzun gelişme aşamasında test amaçlı kullanacağımız bu satır, programımızın nihai sürümünde yer almayacaktır. Başlatılır başlatılmaz gizli kalması gereken sayıyı açık eden program oyun değildir!</p>
<p>Programı birkaç defa çalıştırarak deneyin:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling tahmin_oyunu v0.1.0 (/home/rusdili/projeler/tahmin_oyunu)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
     Running `/home/rusdili/projeler/tahmin_oyunu/target/debug/tahmin_oyunu`
Tuttuğum sayıyı tahmin edin!
Gizli sayı: 73
Tahmininizi girin.
11
Tahmininiz:: 11

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `/home/rusdili/projeler/tahmin_oyunu/target/debug/tahmin_oyunu`
Tuttuğum sayıyı tahmin edin!
Gizli sayı: 69
Tahmininizi girin.
88
Tahmininiz:: 88
</code></pre>
<p>Program her çalıştırıldığında 1 ile 100 arasında tesadüfi bir sayı göstermelidir. Güzel iş!</p>
<h2 id="tahmin-sayısının-gizli-sayı-ile-karşılaştırılması"><a class="header" href="#tahmin-sayısının-gizli-sayı-ile-karşılaştırılması">Tahmin Sayısının Gizli Sayı ile Karşılaştırılması</a></h2>
<p>Elimizde kullanıcıdan alınan bir tahmin sayısı ve tasadüfi olarak üretilen bir <code>gizli_sayı</code> olduğuna göre bunları karşılaştırabiliriz. Kodun bu bölümü Örnek 2-4'te gösterilmekle beraber, henüz açıklayacağımız nedenlerden ötürü derlenmez. </p>
<!-- Kaldım -->
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    let gizli_sayı = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Gizli sayı: {}&quot;, gizli_sayı);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut tahmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut tahmin)
</span><span class="boring">        .expect(&quot;Veri okuma hatası!&quot;);
</span>
    println!(&quot;Tahmininiz: {}&quot;, tahmin);

    match tahmin.cmp(&amp;gizli_sayı) {
        Ordering::Less =&gt; println!(&quot;Sayınız küçük!&quot;),
        Ordering::Greater =&gt; println!(&quot;Sayınız büyük!&quot;),
        Ordering::Equal =&gt; println!(&quot;Kazandınız!&quot;),
    }
}
</code></pre>
<p><span class="caption">Örnek 2-4: İki sayıyı karşılaştırarak olası dönüş değerlerini işlemek.</span></p>
<p>Buradaki ilk yenilik standart kitaplıktaki, <code>std::cmp::Ordering;</code> türünün yeni bir <code>use</code> deyimi kullanılarak kod kapsamına getirilmiş olmasıdır. <code>Result</code> türü gibi bir <code>enum</code> olan <code>Ordering</code> türünün <code>less</code>, <code>Greater</code>, <code>Equal</code> şeklinde üç karşılaştırma varyantı vardır ve bunlar, iki değeri karşılaştırırken ortaya çıkan üç olası sonucu temsil etmekte kullanılırlar.</p>
<p>Koda eklenen ikinci yenilik ise, <code>Ordering</code> türünü kullanmak amacıyla kodun en alt kısmına yerleştirdiğimiz beş yeni satır içeren bir eşleme ifadesidir. İfadenin kullandığı <code>cmp</code> metoduysa bir karşılaştırma işlevidir ve burada iki değerin karşılaştırılması amacıyla kullanılır. Karşılaştırılması istenen değerin referansını alarak çalışan bu metot, <code>tahmin</code> değişkeni içindeki değeri <code>gizli_sayı</code> değişkenindeki değer ile karşılaştıracak ve <code>use</code> anahtar kelimesiyle kod kapsamına aldığımız <code>Ordering</code> türünün varyantlarından uygun olan birini döndürecektir. Elde edilen dönüş değeriyle ne yapılacağına ise <code>tahmin</code> ve <code>gizli_sayı</code> değerlerini karşılaştıran <code>cmp</code> çağrısından döndürülecek olası sonuçlarla eşleştirilen ifadelerle karar verilecektir. </p>
<p>Dilimize <em>eşleme</em> olarak çevirebileceğimiz <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> olası durumları ifade eden dallardan meydana gelir. Bu dallar, bir örüntü <em>(kalıp, şablon)</em> ve eşleme ifadesinin başlangıcında belirtilen değerin bu örüntüyle eşleşmesi halinde yürütülecek olan koddan ibarettir. Eşleştirilecek değeri alan Rust bunu sırasıyla her dalın örüntüsüyle karşılaştıracak ve eşleşen daldaki kodu işletecektir. Rust'ın <code>match</code> yapısı ve örüntüleri, kodunuzda karşılaşabileceğiniz çeşitli durumları ifade etmenize yarayan ve olası her durumun ele alındığından emin olmanızı sağlayan güçlü özelliklerdir. Bu özellikler sırasıyla 6. ve 18. bölümlerde ayrıntılı biçimde ele alınacaktır.</p>
<p>Burada kullanılan eşleme ifadesinin nasıl çalışacağını anlayabilmek için kullanıcının tahmin ettiği sayının 50, rasgele üretilen sayının da 38 olduğunu varsayalım. Kod 50 ile 38 sayılarını karşılaştırdığında, 50 sayısı 38'den büyük olduğundan <code>cmp</code> metodu <code>Ordering::Greater</code> döndürecek ve <code>match</code> ifadesi <code>Ordering::Greater</code> değerini alarak her dalın örüntüsünü teker teker kontrol etmeye başlayacaktır. İlk dalın <code>Ordering::Less</code> örüntüsü kontrol edildiğinde, bu değerin <code>Ordering::Greater</code> ile eşleşmediği görülecek ve bu daldaki kodlar yok sayılarak hemen bir sonraki dala geçilecektir. Geçilen bu dal incelendiğinde, daldaki <code>Ordering::Greater</code> örüntüsünün <code>match</code> ifademizin almış olduğu <code>Ordering::Greater</code> değeriyle aynı olduğu görülecek ve bu koldaki kodlar çalıştırılarak ekrana <code>Sayınız büyük!</code> mesajı yazdırılacaktır. Artık bir eşleme bulunmuş olduğundan <code>match</code> ifadesi kalan son dala bakmaya gerek duymayacak ve çalışmasını sonlandıracaktır.</p>
<p>Ancak Örnek 2-4'ü çalıştırdığımızda henüz derlenmediğini görürüz:</p>
<pre><code class="language-console">$ cargo run
   Compiling libc v0.2.112
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling getrandom v0.2.4
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.4
   Compiling tahmin_oyunu v0.1.0 (/home/rusdili/projeler/tahmin_oyunu)
error[E0308]: mismatched types
   --&gt; src/main.rs:343:22
    |
343 |     match tahmin.cmp(&amp;gizli_sayı) {
    |                      ^^^^^^^^^^^ expected struct `String`, found integer
    |
    = note: expected reference `&amp;String`
               found reference `&amp;{integer}`

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:328:41
    |
328 |     let gizli_sayı = rand::thread_rng().gen_range(1..101);
    |         ----------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `gizli_sayı` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
note: required by a bound in `gen_range`
   --&gt; /home/rusdili/.cargo/registry/src/github.com-1ecc6299db9ec823/rand-0.8.4/src/rng.rs:131:12
    |
131 |         T: SampleUniform,
    |            ^^^^^^^^^^^^^ required by this bound in `gen_range`
help: consider specifying the type arguments in the function call
    |
328 |     let gizli_sayı = rand::thread_rng().gen_range::&lt;T, R&gt;(1..101);
    |                                                  ++++++++

Some errors have detailed explanations: E0283, E0308.
For more information about an error, try `rustc --explain E0283`.
error: could not compile `tahmin_oyunu` due to 2 previous errors
</code></pre>
<p>Çıktıda sorunun <em>tür uyumsuzluğundan</em> kaynaklandığı belirtiliyor. Rust güçlü ve statik tür sistemiyle birlikte türün bağlamdan çıkarsanması özelliğine de sahip bir programlama dili olduğundan, tahmin değişkenini <code>let mut tahmin = String::new()</code> olarak bildirdiğimizde, değişkenin <code>String</code> türünde olacağını varsayar. Fakat programın rastgele ürettiği <code>gizli_sayı</code> ise sayı türüdür. Rust'ta 1 ile 100 arasındaki sayıları gösterebilecek belli başlı sayısal türler vardır. Bunlar, işaretli 32 bitlik sayılar için <code>i32</code>, işaretsiz 32 bitlik sayılar için <code>u32</code>, işaretli 64 bitlik sayılar için kullanılan <code>i64</code> gibi türleridir. Rust tamsayılar için varsayılan olarak <code>i32</code> türünü benimsediğinden, tür bilgisi kodun herhangi bir yerinde açıkça belirtilmedikçe <code>i32</code> olarak varsayılacak, <code>gizli_sayı</code> değişkeni <code>i32</code> olarak atanacaktır. Bu durumda bir <code>String</code> türüyle <code>i32</code> türü karşılaştırılamayacağından Rust, tam olarak karşılaştığımız hatayı üretecektir.</p>
<p>Bu sorunu çözebilmemiz için, kullanıcı girdisi olarak okunan <code>String</code> türünü gerçek bir sayı türüne dönüştürüp, sayısal değerli <code>gizli_sayı</code> değişkeniyle karşılaştırmamız gerekir. Bunu <code>main()</code> işlevine ekleyeğimiz tek satır kod ile gerçekleştirebiliriz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    let gizli_sayı = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Gizli sayı: {}&quot;, gizli_sayı);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut tahmin = String::new();

    io::stdin()
        .read_line(&amp;mut tahmin)
        .expect(&quot;Veri okuma hatası!&quot;);

    let tahmin: u32 = tahmin.trim().parse().expect(&quot;Lütfen bir sayı türü girin!&quot;);

    println!(&quot;Tahmininiz: {}&quot;, tahmin);

    match tahmin.cmp(&amp;gizli_sayı) {
        Ordering::Less =&gt; println!(&quot;Sayınız küçük!&quot;),
        Ordering::Greater =&gt; println!(&quot;Sayınız büyük!&quot;),
        Ordering::Equal =&gt; println!(&quot;Kazandınız&quot;),
    }
<span class="boring">}
</span></code></pre>
<p>Eklenen yeni satır:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tahmin: u32 = tahmin.trim().parse().expect(&quot;Lütfen bir sayı türü girin!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Bu satır <code>tahmin</code> adında yeni bir değişken oluşturur. Hatırlarsanız programımızda kullanılan bir <code>tahmin</code> değişkeni zaten vardı. O halde bu satırda yeniden oluşturulan <code>tahmin</code> değişkenin anlamı nedir? Rust bir değişkeni, aynı adlı başka bir değişkenle değiştirmemize izin verir. Gölgeleme olarak adlandırılan bu özellik, bir değeri olduğu türden başka bir türe çevirmek istediğiniz durumlarda oldukça kullanışlıdır. Bu özellik örneğin <code>tahmin</code> ve <code>bir_başka_tahmin</code> gibi iki farklı değişken oluşturmak yerine <code>tahmin</code> değişken adını tekrar kullanmamıza izin verir. Sıklıkla bir türün başka bir türe dönüştürülmesinde kullanılan  Gölgeleme olanağını 3. Bölümde tartışacağız.</p>
<p>Yeni<code>tahmin</code> değişkenini <code>tahmin.trim().parse()</code> ifadesine bağladığımızda, ifade içindeki <code>tahmin</code>, <code>String</code> türündeki kullanıcı girdisini içeren orjinal <code>tahmin</code> değişkenini gösterir. Bir <code>String</code> örneğine uygulanan <code>trim</code> metodu ise kendisine iletilen dizginin baş ve sonunda bulunan beyaz boşlukları temizler. Her ne kadar <code>u32</code> türü yalnızca sayısal karakterler içeriyor olsa da, kullanıcının <code>read_line</code> işlemini yerine getirmek için enter tuşuna basmasıyla dizgiye yeni bir satır eklenecektir. Örneğin, kullanıcı tahmini ettiği 5 rakamını yazıp enter tuşuna bastığında, <code>tahmin</code> içindeki veri <code>5\n</code> olarak görünecektir. Bu, kullanıcının girdiği rakama İngilizce karşılığı &quot;newline&quot; olan ve <em>yeni bir satırı</em> temsil eden <code>\n</code> karakterinin eklenmesi anlamına gelir. <code>trim</code> metodunun kullanılması, <code>\n</code> karakterinin temizlenerek girdinin sadece 5 olarak kalmasını sağlar. </p>
<p>Dizgilerle kullanılan <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code></a><!-- ignore --> metodu ise, dizgiyi sayı türüne ayrıştırır. Bu metot çeşitli sayı türlerini ayrıştırabildiğinden, istenilen sayı türünün Rust'a tam olarak <code>let tahmin: u32 </code> şeklinde açıkça bildirilmesi gerekir. <code>tahmin</code> değişkeninden sonra gelen <code>(:)</code> iki nokta ise, bildirilen değişkene tür açıklaması ekleneceğini gösterir. Rust'ta birkaç yerleşik sayısal tür bulunur ve burada kullandığımız <code>u32</code> türü, işaretsiz 32 bitlik bir tamsayıyı olduğundan, küçük bir pozitif sayı için uygun bir seçimdir (Diğer sayı türlerini 3. Bölümde inceleyeceğiz.).  <code>tahmin</code> değişkenine <code>u32</code> olarak eklenen tür açıklaması ve <code>tahmin</code> değişkeninin <code>gizli_sayı</code> ile karşılaştırılması sayesinde Rust, bu bağlamdan <code>gizli_sayı</code> değişken türünün <code>u32</code> olacağını çıkarır. Artık karşılaştırma işlemi, aynı türden iki değer arasında gerçekleştirilecektir!</p>
<p>Dizgi içeriğinde <code>A👍%</code> şeklinde bir değerin bulunması halinde, bu değeri bir sayıya sorunsuzca dönüştürmenin herhangi bir yolu olmadığından, <code>parse</code> çağrısı kolaylıkla bir hata üretebilir. Bu nedenle <code>parse</code> metodu, başarısız olma ihtimaline karşı daha önce <a href="ch02-00-guessing-game-tutorial.html#result-t%C3%BCr%C3%BC-ile-olas%C4%B1-hatalar%C4%B1-i%CC%87%C5%9Flemek"><em><code>Result</code> Türü ile Olası Hataları İşlemek</em></a><!-- ignore --> başlığında incelediğimiz gibi ve <code>read_line</code> metoduna benzer şekilde bir <code>Result</code> türü döndürür. Döndürülen <code>Result</code> türünü ise <code>expect</code> metodunu kullanarak değerlendireceğiz. Eğer <code>parse</code> metoduyla dizgiden bir sayı elde edilemez ve <code>Result</code> türü <code>Err</code> varyantını döndürürse <code>expect</code> çağrısı programı çökertecek ve kendisine parametre olarak ilettiğimiz <em>Lütfen bir sayı türü girin!</em> mesajını gösterecektir. Fakat <code>parse</code> metodu başarılı olur ve bir sayı üretebilirse, <code>Result</code> türü <code>Ok</code> varyantını döndüreceğinden <code>expect</code> çağrısından da <code>Ok</code> varyantı içinde depolanan bu değer döndürülmüş olacaktır.</p>
<p>Şimdi programımız yeniden çalıştıralım!</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ ccargo run                                          ✔  5s  
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/tahmin_oyunu`
Tuttuğum sayıyı tahmin edin!
Gizli sayı: 14
Tahmininizi girin.
76
Tahmininiz: 76
Sayınız büyük!

</code></pre>
<p>Kullanıcı girdisiyle alınan 76 sayısının önünde boşluklar olmasına rağmen kodun, tahmin değerini 76 olarak alınabiliyor olması güzel! Lütfen programınızı &quot;Sayınız küçük!&quot;, &quot;Sayınız büyük!&quot; ve &quot;Bildiniz!&quot; seçeneklerini üretecek şekilde birkaç defa çalıştırarak gözlemleyin.</p>
<p>Oyunun büyük bölümü doğru çalışıyor olsa da kullanıcıların yalnızca bir tahmin hakkı olması bütün eğlenceyi bozuyor. Koda bir döngü ekleyerek bu durumu değiştirebiliriz!</p>
<h2 id="döngü-kullanarak-farklı-tahminler-almak"><a class="header" href="#döngü-kullanarak-farklı-tahminler-almak">Döngü Kullanarak Farklı Tahminler Almak</a></h2>
<p>Bir anahtar kelime olan <code>loop</code> sonsuz döngü oluşturur. Kullanıcıların doğru sayıya ulaşmalarını kolaylaştırmak amacıyla programımıza <code>loop</code> döngüsü ekleyecek ve onlara daha fazla şans vereceğiz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    let gizli_sayı = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;Gizli sayı: {}&quot;, gizli_sayı);

    loop {
        println!(&quot;Tahmininizi girin.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut tahmin = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut tahmin)
</span><span class="boring">            .expect(&quot;Veri okuma hatası!&quot;);
</span><span class="boring">
</span><span class="boring">        let tahmin: u32 = tahmin.trim().parse().expect(&quot;Lütfen bir sayı türü girin!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Tahmininiz: {}&quot;, tahmin);
</span><span class="boring">
</span>        match tahmin.cmp(&amp;gizli_sayı) {
            Ordering::Less =&gt; println!(&quot;Sayınız küçük!&quot;),
            Ordering::Greater =&gt; println!(&quot;Sayınız büyük!&quot;),
            Ordering::Equal =&gt; println!(&quot;Kazandınız!&quot;),
        }
    }
}
</code></pre>
<p>Göreceğiniz gibi 'tahmin giriş talebi'nden itibaren olan her şeyi döngü kapsamına taşıyarak, her satır için dört boşluk değerinde girinti oluşturduk. Programı çalıştırdığınızda kodun tam olarak istediğimiz şeyi yapmakla beraber, sonsuza kadar tahmin yapılmasını bekleyen yeni bir sorunun oluştuğunu ve kullanıcıların bu döngüden çıkmasının engellediğini fark edeceksiniz!</p>
<p>Kullanıcılar <em>ctrl+d</em> klavye kısa yolunu kullanarak programı her zaman sonlandırabilirler. Ancak bu doyumsuz canavardan kaçmanın başka bir yolu daha var. Hatırlarsanız <a href="ch02-00-guessing-game-tutorial.html#tahmin-say%C4%B1s%C4%B1n%C4%B1n-gizli-say%C4%B1-ile-kar%C5%9F%C4%B1la%C5%9Ft%C4%B1r%C4%B1lmas%C4%B1">Tahmin Sayısının Gizli Sayı ile Karşılaştırılması</a><!-- ignore --> başlığındaki <code>parse</code> konusundan tartıştığımız gibi, tahmin verisine sayısal olmayan bir değer verilmesiyle programın çökerek sonlanıyordu. O haldei kullanıcıların döngüyü kırarak programdan çıkmalarını sağlamak için bundan yararlanabiliriz.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run 
   Compiling tahmin_oyunu v0.1.0 (/home/rusdili/projeler/tahmin_oyunu)
    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
     Running `target/debug/tahmin_oyunu`
Tuttuğum sayıyı tahmin edin!
Gizli sayı: 26
Tahmininizi girin.
45
Tahmininiz: 45
Sayınız büyük!
Tahmininizi girin.
11
Tahmininiz: 11
Sayınız küçük!
Tahmininizi girin.
30
Tahmininiz: 30
Sayınız büyük!
Tahmininizi girin.
çıkış
thread 'main' panicked at 'Lütfen bir sayı türü girin!: ParseIntError { kind: InvalidDigit }', src/main.rs:178:49
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

</code></pre>
<p>Tahmin değişkenine <em>çıkış</em> gibi sayısal olmayan herhangi bir ifadenin girilmesi programdan çıkılmasına yetiyor gibi görünse de bu mekanizma, &quot;Tahmin sayısının doğru girilmesi halinde programın otomatik olarak sonlanması&quot; talebimizi henüz karşılamıyor.</p>
<h3 id="doğru-tahmin-sonrası-oyundan-Çıkmak"><a class="header" href="#doğru-tahmin-sonrası-oyundan-Çıkmak">Doğru Tahmin Sonrası Oyundan Çıkmak</a></h3>
<p>Kullanıcının doğru tahmin yaparak oyunu kazanması durumunda, programdan çıkılmasını sağlayan <code>break</code> anahtar kelimesini kodlarımıza ekleyelim:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    let gizli_sayı = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Gizli sayı: {}&quot;, gizli_sayı);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut tahmin = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut tahmin)
</span><span class="boring">            .expect(&quot;Veri okuma hatası!&quot;);
</span><span class="boring">
</span><span class="boring">        let tahmin: u32 = tahmin.trim().parse().expect(&quot;Lütfen bir sayı türü girin!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Tahmininiz: {}&quot;, tahmin);
</span><span class="boring">
</span>        // --snip--

        match tahmin.cmp(&amp;gizli_sayı) {
            Ordering::Less =&gt; println!(&quot;Sayınız küçük!&quot;),
            Ordering::Greater =&gt; println!(&quot;Sayınız büyük!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Kazandınız!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Kullanıcın doğru tahmini yaptığı ve &quot;Bildiniz!&quot; mesajının ekrana yazdırıldığı satırın ardına eklenen <code>break</code> ifadesi programın döngüden çıkmasını sağlar. Döngü <code>main</code> işlevinin son bölümü olduğundan döngüden çıkmak aynı zamanda programdan çıkmak anlamına da gelir.</p>
<h3 id="geçersiz-veri-girişlerini-İşlemek"><a class="header" href="#geçersiz-veri-girişlerini-İşlemek">Geçersiz Veri Girişlerini İşlemek</a></h3>
<p>Oyunun davranışını daha da iyileştirebilmek amacıyla, sayısal olmayan bir değer alındığında programı çökertmek yerine, bu değerlerin yok sayılmasını ve kullanıcının doğru sayıyı bulana kadar tahmine devam etmesini sağlayalım. Bu iyileştirmeyi Örnek 2-5'te gösterildiği şekilde, <code>String</code> türündeki <code>tahmin</code> değişkenini, <code>u32</code> türüne dönüştüren satırda değişiklik yaparak gerçekleştirebiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);
</span><span class="boring">
</span><span class="boring">    let gizli_sayı = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Gizli sayı: {}&quot;, gizli_sayı);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Tahmininizi girin.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut tahmin = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut tahmin)
            .expect(&quot;Satır okuma hatası!&quot;);

        let tahmin: u32 = match tahmin.trim().parse() {
            Ok(sayı) =&gt; sayı,
            Err(_) =&gt; continue,
        };

        println!(&quot;Tahmininiz: {}&quot;, tahmin);

        // --snip--
<span class="boring">
</span><span class="boring">        match tahmin.cmp(&amp;gizli_sayı) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Sayınız küçük!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Sayınız büyük!!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Kazandınız!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Örnek 2-5: Sayı olmayan veriyle programı çökertmek yerine yeni bir tahmin istemek</span></p>
<p><code>expect</code> çağrısının <code>match</code> ifadesiyle değiştirilmesi, programı çökerten hatadan düzgün şekilde işlenen hataya geçilmesini sağlar. Ayrıştırma işlemini gerçekleştiren <code>parse</code> metodunun bir <code>Result</code> türü döndürdüğünü ve bu türün <code>OK</code> veya <code>Err</code> varyantlarına sahip bir <code>enum</code> türü olduğunu unutmayın. Tıpkı <code>cmp</code> metodunun <code>Ordering</code> türünden döndürdüğü sonuçları işlediğimiz gibi burada da bir <code>match</code> ifadesi kullandıyoruz.</p>
<p><code>parse</code> metodu dizgiyi bir sayıya düzgünce dönüştürebilirse, elde edilen sayıyı içeren bir <code>Ok</code> değeri döndürülür. Bu değer ilk dalın örüntüsüyle eşleştiğinde <code>match</code> ifadesi, <code>parse</code> ile oluşturulan <code>sayi</code> değerini alarak <code>Ok</code> değerinini içine yerleştirecek ve bu sayı yeni oluşturulan <code>tahmin</code> değişkeninde saklanacaktır.</p>
<p>Dizgi sayıya dönüştürülemiyorsa da, hata hakkında detaylı bilgi içeren <code>Err</code> değeri döndürülücektir. Bu değer <code>match</code> ifadesinin <code>Ok(sayi)</code> dalıylae değil, ikinci daldaki <code>Err(_)</code> kalıbıyla eşleşecektir. Bu kalıpta yer alan alt çizgi <code>_</code> bize, içindeki değerlere bakılmaksızın <code>Err</code> varyantındaki tüm değerlerin bu dal ile eşleştirileceğini söylemektedir. Burası çalıştığında, döngünün bir sonraki yinelemesine atlanarak yeni bir tahmin verisi istemesini sağlayan <code>continue</code> ifadesi işletilecek, böylece <code>parse</code> metodunun karşılaşabileceği olası tüm hatalar yok sayılmış olacaktır.</p>
<p>Bu aşamada artık programımızdaki her şey beklendiği gibi çalışacaktır. Deneyelim:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(Küçük sayı tahmini)
(büyük sayı tahmini)
çıkış
(doğru tahmin)
-->
<pre><code class="language-console">$ cargo run
   Compiling tahmin_oyunu v0.1.0 (/home/rusdili/projeler/tahmin_oyunu)
    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
     Running `target/debug/tahmin_oyunu`
Tuttuğum sayıyı tahmin edin!
Gizli sayı: 63
Tahmininizi girin.
20
Tahmininiz: 20
Sayınız küçük!
Tahmininizi girin.
99
Tahmininiz: 99
Sayınız büyük!
Tahmininizi girin.
çıkış
Tahmininizi girin.
63
Tahmininiz: 63
Kazandınız!

</code></pre>
<p>Mükemmel! Küçük ve son bir ince ayar daha yaptıktan sonra oyunu bitireceğiz. Test aşamasında gizli sayının ekrana yazdırılması önemli bir detayken, bunun sonuç aşamasında halen var olması oyunu mahvediyor. Bu durumu <code>gizli_sayı</code> değişkenini ekrana yazdıran <code>println!</code> satırını silerek düzeltelim. Örnek 2-6 kodun son halini gösterir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Tuttuğum sayıyı tahmin edin!&quot;);

    let gizli_sayı = rand::thread_rng().gen_range(1..101);

    loop {
        println!(&quot;Tahmininizi girin.&quot;);

        let mut tahmin = String::new();

        io::stdin()
            .read_line(&amp;mut tahmin)
            .expect(&quot;Satır okuma hatası!&quot;);

            let tahmin: u32 = match tahmin.trim().parse() {
            Ok(sayı) =&gt; sayı,
            Err(_) =&gt; continue,
        };

        println!(&quot;Tahmininiz: {}&quot;, tahmin);

        match tahmin.cmp(&amp;gizli_sayı) {
            Ordering::Less =&gt; println!(&quot;Sayınız küçük!&quot;),
            Ordering::Greater =&gt; println!(&quot;Sayınız büyük!!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Kazandınız!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Örnek 2-6: Tahmin oyunu programının son hali</span></p>
<h2 id="Özet-1"><a class="header" href="#Özet-1">Özet</a></h2>
<p>Tebrikler! Başarıyla çalışan bir sayı tahmin oyunu programladınız.</p>
<p>Bu proje, <code>let</code>, <code>match</code>, <em>metotlar</em>, <em>ilişkili işlevler</em>, harici sandıkların kullanılması gibi birçok Rust kavramını size tanıtmanın uygulamalı bir yoluydu. Kitabın ilerleyen bölümlerinde bu kavramlar hakkında daha çok şey öğreneceksiniz. 
3. Bölümde değişkenler, veri türleri, işlevler gibi çoğu programlama dili tarafından kullanılan kavramları kapsanacak ve bunların Rust ile nasıl kullanıldığı gösterilecektir. 4. Bölümde ise Rust'ı diğer dillerden ayıran önemli bir özellik olan mülkiyet kavramı incelenecek, 5. Bölümde yapı ve metot söz dizimleri tartışılacak, 6. bölümdeyse <code>enum</code> türünün çalışması irdelenecektir.</p>
<!-- 
std bağlantıları kontrol edildi
örnek kontrolü yapılacak
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="ortak-programlama-kavramları"><a class="header" href="#ortak-programlama-kavramları">Ortak Programlama Kavramları</a></h1>
<p>Bu bölüm neredeyse tüm programlama dillerinde görülen kavramları ve bu kavramların Rust'ta nasıl çalıştığını kapsar. Pek çok dilin özünde birbiriyle ortak noktalar olduğundan bu bölümde sunulan kavramların hiçbiri Rust'a özgü değildir. Ancak biz bu kavramları Rust bağlamında tartışacak ve kullanımlarıyla ilgili kuralları açıklayacağız.</p>
<p>Özellikle değişkenler, temel türler, işlevler, yorum ve kontrol akışı hakkında bilgi edineceksiniz. Henüz yolun başındayken Rust programlama alt yapısını oluşturan bu bilgilerin öğrenilmesi size sağlam bir temel kazandıracaktır.</p>
<blockquote>
<h4 id="anahtar-kelimeler"><a class="header" href="#anahtar-kelimeler">Anahtar Kelimeler</a></h4>
<p>Diğer programlama dillerinde olduğu gibi Rust dilinde de, yalnızca dilin kullanabileceği bir dizi anahtar
kelime vardır. Bu kelimeleri değişken veya işlev adlarında kullanamazsınız. Çoğu anahtar kelime özel bir anlam taşıdığından
Rust programlarındaki çeşitli görevlerde bu kelimelerden faydalanacaksınız. Her ne kadar bu kelimelerden bazıları şu an için 
işlevsel değilmiş gibi görünse de, bunlar yakın gelecekte Rust'a eklenmesi planlanan işlevler için ayrılmıştır. Bu anahtar
kelimelerin listesi kitabınızın <a href="appendix-01-keywords.html">Ek A</a><!-- ignore --> bölümünde bulunmaktadır.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="değişkenler-ve-değişkenlik"><a class="header" href="#değişkenler-ve-değişkenlik">Değişkenler ve Değişkenlik</a></h2>
<p><a href="ch02-00-guessing-game-tutorial.html#degerleri-degiskenlerde-saklamak">“Değerleri Değişkenlerde Saklamak”</a><!-- ignore --> bölümünden hatırlayacağınız üzere Rust'ta değişkenler varsayılan olarak değişmez kabul edilmekteydi. Bu kabul kodlarınızı, Rust'ın getirdiği güvenlik ve eşzamanlılık avantajlarından yararlanacak şekilde yazmanızı teşvik eden birçok Rust yaklaşımından biridir. Ancak yine de değişkenlerinizi değişebilir yapma seçeğine her zaman sahipsiniz. Şimdi gelin Rust'ın sizi değişmezliğe nasıl ve neden yönlendirdiğini ve bazen bu değişemezlikten neden vazgeçmemiz gerektiğini birlikte inceleyelim.</p>
<p>Bir değişmez haldeki bir değişkene isim verilerek değer atandığında o değişkenin değerini artık değiştiremezsiniz. Bu konuya açıklık getirebilmek için projeler dizininde <code>cargo new degiskenler</code> komutunu kullanarak <em>degiskenler</em> adında yeni bir proje oluşturalım. Ardından <em>degiskenler</em> dizinindekki <em>src/main.rs</em> dosyasını açarak içindeki kodları şu an için derlenmeyen aşağıdaki kodlarla değiştirelim: </p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;x'in değeri: {}&quot;, x);
    x = 6;
    println!(&quot;x'in değeri: {}&quot;, x);
}
</code></pre>
<p>Programınızı kaydedip <code>cargo run</code> komutuyla çalıştırdığınızda aşağıdakine gibi bir hata mesajı alacaksınız:</p>
<pre><code class="language-console">$ cargo run
   Compiling degiskenler v0.1.0 (/home/rustdili/projeler/degiskenler)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;x'in değeri: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `no-listing-01-variables-are-immutable` due to previous error
</code></pre>
<p>Bu örnek, derleyicinin programlarınızdaki hataları bulmanıza nasıl yardımcı olacağını gösterir. Deneyimli Rust geliştiricilerinin bile karşılaşmaktan muaf olmadığı bu sinir bozucu görünen derleyici hataları, sizin kötü programcı olduğunuzu değil, programınızın yapması gereken şeyleri henüz güvenli bir şekilde gerçekleştiremediğini söylemektedir.</p>
<p>Hata mesajındaki <code>cannot assign twice to immutable variable `x`</code> uyarısı hatanın sebebi olarak <strong>değişmez olarak bildirilen <code>x</code> değişkenine ikinci kez değer atanamayacağını</strong> ancak bizim <code>x</code> değişkenine yeni bir değer atamaya çalıştığımızı bildirmektedir.</p>
<p>Değişmez olarak belirlenmiş bir değeri değiştirmeye çalışmak programda hatalara neden olabileceğinden böyle bir derleme zamanı hatası almamız önemlidir. Kodumuzun bir bölümünün bir değerin asla değişmeyeceği varsayımıyla hareket ettiği oysa başka bir bölümün bu değeri değiştirdiğini düşündüğünüzde kodun ilk bölümünün tasarlandığı gibi çalışmayacağı ortadadır. Bu şekilde ortaya çıkan hataların kaynağını saptamak, değişken değeri ara sıra değiştirildiğinde daha da çok zorlaşır. 
Rust'ta bir değerin değişmeyeceğini bildirdiğinizde derleyici bu değerin değişmeyeceğini garanti eder. Bu garanti bir kodu okur veya yazarken, değerlerin nerede ve nasıl değişeceğini takip etmenize gerek olmadığı anlamına gelmekte ve kodlarınızın kolayca anlaşılmasını sağlamaktadır.</p>
<p>Ancak değişebilirlik pratik kod yazmak gibi çok sayıda fayda sağlar. Değişkenler yalnızca varsayılan olarak değişmez olduklarından, tıpkı 2. Bölümde yaptığımız gibi önlerine <code>mut</code> kelimesini ekleyerek onları değişebilirsinizr. Anahtar kelime <code>mut</code>'un eklenmesi ileride bu kodu okuyacaklara, bu değişken değerinin kodun diğer bölümleri tarafından değiştirileceğini de gösterir.</p>
<p>Örneğin <em>src/main.rs</em> dosyasını aşağıdaki şekilde değiştirelim:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Programı bu şekilde çalıştırdığımızda aşağıdaki çıktıyı elde ederiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling degiskenler v0.1.0 (/home/rustdili/projeler/degiskenler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/degiskenler`
x'in değeri: 5
x'in değeri: 6
</code></pre>
<p><code>mut</code>'u kullanmakla <code>x</code>'e bağlı olan <code>5</code> değerinin <code>6</code> olarak değiştirilmesine izin vermiş oluruz. Hatalardan kaçınmanın yanı sıra verilmesi gereken başka tavizler de vardır. Örneğin, büyük yapılarla çalışırken mevcut bir örneği yerinde değiştirmek, yeni atanacak örneklerin kopyalanarak geri döndürülmesinden daha hızlı olabilir. Yahut küçük veri yapılarıyla çalışılırken yeni örnekler oluşturmak ve işlevsel programlama tarzından daha fazla yararlanmak anlaşılabilirliği arttıracağından, bu netlik uğruna performanstan ödün vermek göze alınabilecek bir tercih olabilir.</p>
<h3 id="sabitler"><a class="header" href="#sabitler">Sabitler</a></h3>
<p>Değişmez değişkenler gibi sabitler de bir isme bağlı olan ve değiştirilmesine izin verilmeyen değerlerdir, ancak sabitler ve değişkenler arasında bazı farklılıklar bulunur.</p>
<p>Bunlardan ilki, <code>mut</code> anahtar kelimesinin sabitler ile kullanılmasına izin verilmez. Sabitler sadece varsayılan olarak değil daima değişmez olarak kabul edilirler. Sabitleri <code>let</code> anahtar sözcüğü yerine <code>const</code> anahtar sözcüğü kullanarak bildirebilirsiniz. Bu bildirim sırasında depoladıkları değer türünü açıkça belirtmelisiniz. Türler ve tür ek açıklamaları konusunu bir sonraki konumuz olan <a href="ch03-02-data-types.html#veri-turleri">Veri Türleri</a><!-- ignore --> bölümünde inceleyeceğimizden bu konunun ayrıntıları hakkında endişelenmeniz gerekmez. Şimdilik sabitleri bildirdiğiniz esnada türün açıkça belirtilmesi gerektiğini anımsamanız yeterlidir.</p>
<p>İkinci olarak sabitler, küresel kapsam dahil herhangi bir kapsamda bildirilebilirler. Bu da onların, kodun farklı bölümlerinde bilinen değerler olarak kullanılmasını sağlar.</p>
<p>Son olarak sabitler yalnızca bir işlev çağrısı sonucu olmayan sabit bir ifadeye veya çalışma zamanında hesaplanabilen başka bir değere ayarlanabilirler. </p>
<p>Aşağıda bir sabit örneği yer almaktadır:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const ÜÇ_SAATTEKİ_SANİYELER: u32 = 60 * 60 * 3;
<span class="boring">}
</span></code></pre></pre>
<p><code>ÜÇ_SAATTEKİ_SANİYELER</code> adlı sabit üç saatin içinde kaç saniye olduğu bilgisini tutar. Ve değeri bir dakia içindeki saniye sayısı (60) ile bir saat içindeki dakika sayısı (60) ve saat sayısı olan (3)'ün çarpımına ayarlıdır. Rust'ın sabitler için adlandırma kuralı, kelimele aralarının alt çizgi ile ayrılması ve tüm harflerin büyük olarak kullanılmasıdır. Derleyici derleme zamanında bir dizi işlemi değerlendirebileceğinden, değerin doğrudan 10,800 olarak ayarlanması yerine, anlaşılması ve doğrulaması daha kolay olan biçimde yazılmasına izin verir. Sabit bildiriminde kullanılabilecek işlemler hakkında bilgilenmek için <a href="https://doc.rust-lang.org/reference/const_eval.html">Rust Reference bölümündeki sabit değerlendirme</a> bölümünü inceleyebilirsiniz.</p>
<p>Sabitler, bir programın çalıştığı süre boyunca, bildirildikleri kapsam dahilinde geçerlidir. Bu durum onları, uygulamanızın farklı bölümlerinden erişilebilen, bir oyuncunun alabileceği maksimum puan sayısı veya ışık hızı gibi belirgin değerlerin bilinmesi gerektiğinde oldukça kullanışlı bir seçenek haline getirir.</p>
<p>Programınız genelinde kullanılan sabit olarak kodlanmış değerleri sabit olarak adlandırmak, bu değerin anlamını ileride kodun bakımını üstlenecek geliştiricilere iletmede faydalıdır. Bununla birlikte sabit olarak kodlanmış bir değerin olası bir güncelleme durumunda tek bir yerden değiştirilecek olması kod bakımı için oldukça yararlıdır.</p>
<h3 id="gölgeleme"><a class="header" href="#gölgeleme">Gölgeleme</a></h3>
<p>Bir önceki <a href="ch02-00-guessing-game-tutorial.html#tahmin-sayisinin-gizli-sayi-ile-karsilastirilmasi">&quot;Tahmin Sayısının Gizli Sayı ile Karşılaştırılması&quot;</a><!-- ignore --> bölümünden hatırlayacağınız üzere daha önce tanımlanmış bir değişken adıyla yeni bir değişken tanımlayabilirsiniz. Rust geliştiricileri tarafından önce tanımlanan değişkenin sonraki tarafından gölgelendiği ifade edilen bu durum, değişkenin kullanılması durumunda ikinci değişkene ait değerin elde edileceği anlamına gelmektedir. Aşağıdaki örnekte gösterildiği gibi, bir değişkeni aynı isimle ve <code>let</code> anahtar kelimesi tekrar kullanarak gölgeleyebiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;Kapsam içindeki x'in değeri: {}&quot;, x);
    }

    println!(&quot;x'in değeri: {}&quot;, x);
}
</code></pre></pre>
<p>Bu program ilk olarak <code>x</code> değişkenini 5 değerine bağlar. Ardından <code>let x =</code> ifadesini tekrarlanması sonucu <code>x</code> değişkenini, <code>x</code>'in orijinal değerini alıp üzerine <code>1</code> ekleyerek <code>6</code> olacak şekilde gölgeler. Ardından gelen iç kapsamda ise değer üçüncü kez gölgelenerek önceki değer <code>2</code> ile çarpılır ve <code>x</code> değişkeni <code>12</code> değerini almış olur. İç kapsamdan çıkıldığında içeride yapılmış olan gölgeleme de sona ereceğinden x yeniden <code>6</code> değerine döner. Program çalıştırıldığında aşağıdaki çıktıyı verecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling degiskenler v0.1.0 (/home/rustdili/projeler/degiskenler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.77s
     Running `target/debug/degiskenler`
Kapsam içindeki x'in değeri: 12
x'in değeri: 6
</code></pre>
<p>Gölgeleme, bir değişkeni <code>mut</code> olarak işaretlemekten farklıdır. Bir değişkeni <code>let</code> anahtar kelimesi kullanmadan yeniden atamaya çalışmak derleme zamanı hatasıyla sonuçlanır. Bir değer üzerinde <code>let</code> anahtar kelimesi kullanarak bazı dönüşümler yapabiliyor olsak bile, bu dönüşümler bittiğinde değişken yine bir değişmez olarak kalacaktır.</p>
<p>Gölgeleme ve <code>mut</code> arasındaki bir diğer fark ise <code>let</code> anahtar kelimesini tekrar kullanmakla etkili bir şekilde yeni bir değişken oluşturduğumuzdan, değerin türünü değiştirebilir ve değişkeni aynı adla kullanmaya devam edebiliriz. Örneğin kullanıcılara gösterilecek metinler arasında kaç boşluk olması gerektiğini soran ve girilen bu boşluk değerlerini sayı olarak saklamak istediğimizi düşünelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let boşluk = &quot;   &quot;;     // Üç boşluk
    let boşluk = boşluk.len();
<span class="boring">}
</span></code></pre></pre>
<p>İlk <code>boşluk</code> değişkeni <code>string</code> (dizgi), alt satırdaki birinciyle aynı adı taşıyan fakat yepyeni bir değişken olan <code>boşluk</code> değişkeniyse tam sayı türünde olduğundan bu yapıya izin verilir. Gölgelemenin bu avantajı sayesinde <code>boşluk_dizgi</code> ve <code>boşluk_sayı</code> gibi farklı değişkenler oluşturmadan, <code>boşluk</code> adını tekrar kullanmakla bu sorunlardan kurtuluvermiş oluruz. Eğer bunun yerine <code>mut</code> anahtar sözcüğünü aşağıdaki gibi kullanmaya kalkarsak bir derleme zamanı hatası alırız.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut boşluk = &quot;   &quot;; // Üç boşluk
    boşluk = boşluk.len();
<span class="boring">}
</span></code></pre>
<p>Hata bize bir değişken türünün değiştirilmesine izin verilmediğini bildiriyor. </p>
<pre><code class="language-console">$ cargo run                                                                                                                       ✔ 
   Compiling degiskenler v0.1.0 (/home/rusdili/projeler/degiskenler)
error[E0308]: mismatched types
  --&gt; src/main.rs:48:14
   |
47 |     let mut boşluk = &quot;   &quot;; // Üç boşluk
   |                      ----- expected due to this value
48 |     boşluk = boşluk.len();
   |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `degiskenler` due to previous error
</code></pre>
<p>Artık değişkenlerin nasıl çalıştığını anladığımıza göre alabilecekleri veri türlerini inceleyebiliriz. </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="veri-türleri"><a class="header" href="#veri-türleri">Veri Türleri</a></h2>
<p>Rust'taki düm değerlerin belirli bir veri türüne ait olması Rust'a ne tür verilerin bildirildiği ve bu verilerin nasıl işleneceğini söyler. Bu başlıkta skaler ve bileşik olmak üzere iki <em>veri türü</em> alt kümesine odaklanacağız.</p>
<p>Rust'ın <em>statik olarak yazılmış</em> bir dil olduğunu ve tüm değişken türlerinin derleme sırasında  biliniyor olması gerektiğini unutmayın. Derleyici genellikle değere ve onu nasıl kullandığımıza bağlı olarak kullanmak istediğimiz türü anlayabilir. Ancak çıkarsanabilecek farklı türlerin olması durumunda, kitabımızın 2. bölümünde yer alan <a href="ch02-00-guessing-game-tutorial.html#tahmin-say%C4%B1s%C4%B1n%C4%B1n-gizli-say%C4%B1-ile-kar%C5%9F%C4%B1la%C5%9Ft%C4%B1r%C4%B1lmas%C4%B1">&quot;Tahmin Sayısının Gizli Sayı ile Karşılaştırılması&quot;</a><!-- ignore -->  bölümünde String türünü sayısal bir türe dönüştürürken yaptığımız gibi tür ek açıklaması eklememiz gerekir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tahmin: u32 = &quot;42&quot;.parse().expect(&quot;Lütfen bir sayı türü girin!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Böyle bir ifadeye tür ek açıklaması eklenmezse Rust derleyicisi aşağıdaki gibi, kullanılmak istenen türün açıkça bildirilmesi gerektiğini söyleyen bir hata döndürecektir:</p>
<pre><code class="language-console">$ cargo run                                                                                                                   ✔
   Compiling degiskenler v0.1.0 (/home/rusdili/projeler/degiskenler)
warning: unused variable: `tahmin`
  --&gt; src/main.rs:54:9
   |
54 |     let tahmin: u32 = &quot;42&quot;.parse().expect(&quot;Lütfen bir sayı türü girin!&quot;);
   |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_tahmin`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: `degiskenler` (bin &quot;degiskenler&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.72s
     Running `/home/rusdili/projeler/degiskenler/target/debug/degiskenler`
</code></pre>
<p>Diğer veri türleri için farklı tür ek açıklamaları göreceksiniz.</p>
<h3 id="skaler-veri-türleri"><a class="header" href="#skaler-veri-türleri">Skaler Veri Türleri</a></h3>
<p>Bir <em>skaler</em> tür tek bir değeri temsil eder. Rust'ta dört ana skaler tür bulunur: Tamsayılar, kayan noktalı sayılar, boolean'lar ve karakterler. Diğer programlama dillerinden aşina olduğunuz bu türlerin Rust'ta nasıl çalıştığını inceleyelim.</p>
<h4 id="tamsayı-türleri"><a class="header" href="#tamsayı-türleri">Tamsayı Türleri</a></h4>
<p>Tamsayılar kesirli bileşeni olmayan sayılardır. Hatırlarsanız kitabımızın 2. Bölümünde <code>u32</code> türünde bir tamsayı kullanmıştık. Bu tür bildirimi, ilişkilendirildiği değerin bellekte 32 bitlik bir alanı kaplayan işaretsiz bir tamsayı olması gerektiğini belirtir. İşaretli tamsayılar <code>i</code>, işaretsiz tamsayılar ise <code>u</code> ön ekini alırlar. Tablo 3-1, Rust'ın yerleşik olan tamsayı türlerini göstermektedir. Tıpkı <code>i16</code> örneğinde olduğu gibi. <strong>İşaretli</strong> ve <strong>İşaretsiz</strong> sütunlardaki her seçenek, bir tamsayı değerinin türünü bildirmek için kullanılabilir.</p>
<p><span class="filename">Tablo 3-1: Rust'ın Tamsayı Türleri</span></p>
<table><thead><tr><th>Uzunluk</th><th>İşaretli</th><th>İşaretsiz</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>Her varyant işaretli veya işaretsiz olabileceği gibi bit cinsinden belirli bir boyuta sahiptir. Varyantın işaretli olması sayının negatif değerler alabileceğini, işaretsiz olmasıysa sayının yalnızca pozitif olabileceği anlamına gelmektedir. Başka bir ifadeyle, sayının bir işaretli alması gerekip gerekmediğini <em>işaretli</em>, sayının sadece pozitif olacağını ve bir işaret ile gösterilmesi gerekmediğiniyse <em>işaretsiz</em> sayılar temsil eder. Bir sayıyı kağıda yazarken yaptığımız gibi, işaretin önemli olduğu hallerde sayıyı +, veya - olarak işaretlememize, pozitif olduğu hallerdeyse işaretsiz koymadan kullanmamıza benzer. İşaretli sayılar <a href="https://tr.wikipedia.org/wiki/%C4%B0kinin_t%C3%BCmleyeni">ikinin tümleyeni</a><!-- ignore --> gösterimi kullanılarak depolanır.</p>
<p>Her işaretli varyant -(2<sup>ⁿ⁻¹</sup>) ile 2<sup>ⁿ⁻¹<sup>-1 arasındaki sayıları depolayabilir. Formüldeki <em>n</em> ise varyantın kullandığı bit sayısını gösterir. Bu bir <code>i8</code> varyantının -(2<sup>⁷</sup>) ile 2<sup>⁷</sup>-1 arasındaki sayıları yani -128 ile 127 değerleri arasındaki sayıları depolayabileceğini gösterir. İşaretsiz varyantlar ise 0 ile 2<sup>ⁿ⁻¹<sup> arasındaki sayıları saklayabildiklerinden, bir <code>u8</code> varyantının 0 ile 2<sup>⁸</sup> - 1, yani 0 ile 255 arasındaki sayıları depolayabilirler.</p>
<p>Ek olarak boyutları ve kullanım türleri programın çalıştığı bilgisayar mimarisine bağlı olan <code>isize</code> ve <code>usize</code> türleri vardır. Bunlar 64 bit mimari kullanıyorsanız 64, 32 bit mimari kullanıyorsanız 32 bit olarak değerlendirilirler.</p>
<p>Tamsayı değişmezlerinizi tablo 3-2'de gösterilen biçimlerden herhangi biriyle yazabilirsiniz. Bayt değişmezi haricindeki tüm değişmez değerlerin, <code>57u8</code> gibi bir tür son ekine ve <code>1_000</code> örneğinde olduğu gibi görsel bir ayırıcı olarak <code>_</code> kullanmanıza izin verdiğini unutmayın.</p>
<p><span class="caption">Tabl0 3-2: Rust'taki Tamsayı Değişmezleri</span></p>
<table><thead><tr><th>Sayısal Değişmez</th><th>Örnek</th></tr></thead><tbody>
<tr><td>Ondalık</td><td><code>98_222</code></td></tr>
<tr><td>Onaltılık</td><td><code>0xff</code></td></tr>
<tr><td>Sekizlik</td><td><code>0o77</code></td></tr>
<tr><td>İkilik</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Bayt (sadece<code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>Tam sayı türlerini seçerken kararsız kaldığınızı hissederseniz Rust'ın varsayılan türleri ile devam edebilirsiniz. Rust'ta tam sayılar için varsayılan tür <code>i32</code> 'dir. Bazı koleksiyonları indexlenmesi gerekiyorsa bunun için genellikle <code>isize</code> veya <code>usize</code> türü kullanılır.</p>
<blockquote>
<h5 id="tamsayı-taşması"><a class="header" href="#tamsayı-taşması">Tamsayı Taşması</a></h5>
<p>0 ile 255 arasında değerlere sahip olabilen <code>u8</code> türünde bir değişkeniniz olduğunu varsayalım. Değişkeni bu aralığın
dışında, örneğin 256 gibi türün tutabileceği en yüksek değerden fazla bir değere ayarlamaya çalışırsanız tamsayı taşması
oluşacaktır. Rust'ın hata ayıklama (debug) modu derleme seçeneği, böyle bir davranışın oluşması halinde programı çalışma
zamanında paniğe yol açacak şekilde tamsayı taşması denetimlerini içermektedir. Rust'ta <em>panik</em> terimi, bir  hata nedeniyle
programdan çıkıldığı anlamına gelir. 
Bu konuyu kitabımızın 9. Bölümünde <a href="ch09-01-unrecoverable-errors-with-panic.html">&quot;<code>panic!</code> ile Düzeltilemeyen Hatalar&quot;</a><!-- ignore -->
başlığında yakından inceleyeceğiz.</p>
<p>Tamsayı taşması kontrolleri yayın modunda <code>--release</code> bayrağıyla yapılan derlemelerde gerçekleştirilmez. Ancak taşma 
oluşması halinde taşan değerler Rust tarafından ikinin tümleyeni yöntemiyle sarmalanarak, türün sahip olduğu en küçük 
değerden başlayıp ileriye doğru kaydırılır. Taşmanın <code>u8</code> türünde olduğunu varsaydığımızda bu kaydırmalar, 256 değeri 
için 0'a, 257değeri içinse 1'e evrilir ve rakam yükseldikçe bu böyle devam eder. Program panikleyerek sonlanmaz 
fakat değişken olasılıkla beklenmeyen bir değere sahip olur. Tamsayı taşmaları için sarmalama yöntemine güvenmek bir hata
olarak kabul edilir.</p>
<p>Taşma olasılıklarının açıkça yönetilebilmesi amacıyla standart kütüphanenin temel türlere özgü sağladığı Aşağıdaki 
gibi metotlardan yararlanabilirsiniz: </p>
<ul>
<li>Tüm modları <code>wrapping_add</code> gibi <a href="https://doc.rust-lang.org/std/num/struct.Wrapping.html"><code>wrapping_*</code></a><!-- ignore --> metodlarıyla sarmalayın.</li>
<li>Taşmanın gerçekleşebileceği durumları <code>checked_*</code> metodlarıyla denetleyip <code>None</code> değeri döndürecek şekilde yönetin.</li>
<li>Taşmanın meydana gelip gelmediğini bir boolean değer döndürerek gösteren <code>overflowing_*</code> metodlarından yararlanın.</li>
<li>En yüksek ve en düşük değerleri doyurucu aritmetik işlemlerinden yararlanan  <code>saturating_*</code> metodlarını kullanarak doyurun.</li>
</ul>
</blockquote>
<h4 id="kayan-noktalı-türler"><a class="header" href="#kayan-noktalı-türler">Kayan Noktalı Türler</a></h4>
<p>Ondalık sayılar olarak bildiğimiz kayan noktalı sayılar için Rust'ta iki temel tür bulunur. Bunlar sırasıyla 32 bit boyutunda olan <code>f32</code> ve 64 bit boyutunda olan <code>f64</code> türleridir. Modern CPU'larda <code>f32</code> ve <code>f64</code> türleri aynı hızda çalıştığından Rust'ın kayan noktalı sayılar için varsayılanı daha yüksek bir hassasiyete sahip olan <code>f64</code> türüdür. Kayan noktalı türlerin tümü işaretlidir.</p>
<p>Aşağıdaki örnek kayan noktalı sayıların işleyişini göstermektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0;        // Varsayılan tür: f64

    let y: f32 = 3.0;   // Tercihe bağlı tür: f32
}
</code></pre></pre>
<p>Kayan noktalı sayılar IEEE-754 standardına göre temsil edilir. Buna göre <code>f32</code> tek, <code>f64</code> ise çift hassasiyetli türlerdir.</p>
<h4 id="sayısal-İşlemler"><a class="header" href="#sayısal-İşlemler">Sayısal İşlemler</a></h4>
<p>Rust, tüm sayı türleri için; toplama, çıkarma, çarpma, bölme, kalan gibi ihtiyaç duyacağınız temel matematik işlemlerini destekler. Tam sayılar bölündüğünde bir altındaki en yakın sayıya yuvarlanır. Aşağıdaki örnek türlerin <code>let</code> ifadeleriyle nasıl kullanılabileceğini göstermektedir: </p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Toplama
    let toplam = 5 + 10;

    // Çıkarma
    let fark = 95.5 - 4.3;

    // Çarpma
    let sonuç = 4 * 30;

    // Bölme
    let bölüm = 56.7 / 32.2;
    let yuvarlama = 2 / 3; // Sonuç 0

    // Kalan
    let kalan = 43 % 5;
}
</code></pre></pre>
<p>Her ifade metematiksel işleçler kullanarak ilgili değişkene atanacak olan benzersiz bir değeri hesaplar. Rust'ta yer alan  matemetiksel işleçler bu kitabın <a href="appendix-02-operators.html">EK B</a><!-- ignore --> bölümünde listelenmektedir.</p>
<h4 id="boolean-türü"><a class="header" href="#boolean-türü">Boolean Türü</a></h4>
<p>Çoğu programlama dilinde olduğu gibi Rust'taki boolean türü de <code>true</code> ve <code>false</code> olmak üzere bir baytlık iki olası değerden birine sahiptir. Bu tür Rust'ta <code>bool</code> olarak belirtilir. Örneğin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // Tür ek açıklamasıyla
}
</code></pre></pre>
<p>Boolean değerleri genellikle <code>if</code> gibi koşullu ifadelerle kullanılır. Bu ifadenin çalışma şeklini <a href="ch03-05-control-flow.html">&quot;Kontrol Akışı&quot;</a><!-- ignore --> bölümünde ele alacağız.</p>
<h4 id="karakter-türü"><a class="header" href="#karakter-türü">Karakter Türü</a></h4>
<p>Rust'ın karakter türü dilin en temel alfabetik türüdür ve kullanılışı aşağıdaki gibi örneklenebilir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let kalp_gozlü_kedi = '😻';
}
</code></pre></pre>
<p>Çift Tırnak kullanan dizgi değişmezlerinin tersine <code>char</code> değişmezleri tek tırnakla bildirilir. Rust'ın <code>char</code> türü dört baytlık bir Unicode skaler değerini temsil ettiğinden ASCII karakter tablosunda bulunandan daha çok karakteri temsil eder. Aksanlı harfler, Çin, Japon, Kore, Türk dilindeki karakterler, emoji ve sıfır genişlik boşukların tamamı Rust'ta geçerli <code>char</code> değerlerdir. Unicode skaler değerleri <code>U+0000</code> ile <code>U+D7FF</code> ve <code>U+E000</code> ile <code>U+10FFFF</code> arasında değişir. Ancak &quot;karakter&quot; kavramı Unicode için gerçek bir kavram olmadığından, karakterin anlamına dair insan sezgisi ile Rust'taki karakterin anlamı tam olarak uyuşamayabilir. Bu konuyu 8. Bölümde <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">&quot;UTF-8 Kodlu Metni Dizgilerde Saklamak&quot;</a><!-- ignore --> bölümünde ayrıntılarıyla inceleyeceğiz.</p>
<h3 id="bileşik-veri-türleri"><a class="header" href="#bileşik-veri-türleri">Bileşik Veri Türleri</a></h3>
<p>Bunlar çok sayıda değeri tek bir tür olarak gruplayabilen türlerdir. Rust'ta diziler ve çokuzlular olmak üzere iki temel <em>bileşik tür</em> bulunur.</p>
<h4 id="Çokuzlu-türü"><a class="header" href="#Çokuzlu-türü">Çokuzlu Türü</a></h4>
<p>Çeşitli türlerden oluşan bir dizi değeri, tek bir bileşik tür halinde guruplamanın genel yoludur. Sabit uzunluktaki bu tür bir kez bildirildikten sonra büyüyüp küçülemez.</p>
<p>Parantez içinde virgülle ayrılmış değerler listesi yazarak oluşturulur ve çokuzlunun her konumu bir türü temsil eder. Bununla birlikte içerdiği farklı değerlerin aynı türden olmaları gerekmez. Örnekteki tür ek açıklamaları isteğe bağlı olarak eklenmiştir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let çokuz: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>Çokuzlu tek bir bileşik öğe olarak kabul edildiğinden <code>çokuz</code> değişkeni tüm çokuzluya bağlanır. Bir çokuzluyu çözerek içerdiği her öğeye erişebilmek için örüntü eşlemeyi kullanabiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let çokuz = (500, 6.4, 1);

    let (x, y, z) = çokuz;

    println!(&quot;Değişken y değeri: {}&quot;, y);
}
</code></pre></pre>
<p>Bu program ilk önce bir çokuzlu oluşturarak onu <code>çokuz</code> değişkenine bağlar. Ardından <code>çokuz</code> değişkeni alınıp, <code>x</code>, <code>y</code> ve <code>z</code> adlarında üç ayrı değişkene dönüştürüleceği <code>let</code> ifadesi kullanan bir modelden yararlanılır. Bu işleme, bir çokuzluyu alarak üç parçaya ayırıp, her parçayı ayrı bir değişkene dönüştürmesinden dolayı <em>çözme, yıkma</em> anlamına gelen <em>destructuring</em> adı verilir. Nihayetinde program <code>y</code> değerinin karşılığı olan <code>6.4</code>'ü ekrana yazdırmış olur.</p>
<p>Bu yöntemine ek olarak çokuzlunun öğelerine isminden hemen sonra bir  (<code>.</code>) nokta ve öğe dizin numarası yazarak doğrudan erişebiliriz. Örneğin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let beş_yüz = x.0;

    let altı_nokta_dört = x.1;

    let bir = x.2;
}
</code></pre></pre>
<p>Bu program <code>x</code> adında bir çokuzlu oluştur ve ardından her öğenin dizin numarasını kullanarak onlardan yeni değişkenler üretir. Bir çokuzlunun dizin numarası çoğu programlama dilinde olduğu gibi 0'dan başlar.</p>
<p>Hiç bir değere sahip olmayan <code>()</code> boş bir çokuzlu yalnızca bir değere sahip özel bir türdür ve <code>()</code> şeklinde yazılabilir. Bu türe <em>birim türü</em> değerine ise <em>birim değer</em> adı verilir. Hiç bir değer döndürmeyen ifadeler örtük olarak birim değer döndür.</p>
<h4 id="dizi-türü"><a class="header" href="#dizi-türü">Dizi Türü</a></h4>
<p>Çok sayıda değerden oluşan bir koleksiyona sahip olmanın başka yolu da dizilerden yararlanmaktır. Çokuzlunun tersine bir dizinin her elemanı aynı türden olmalıdır. Bazı dillerdeki dizilerin aksine, Rust'taki dizilerin uzunluğu sabittir. </p>
<p>Bir dizinin değerlerini köşeli parantezler içine ve virgülle ayrılmış liste olarak yazarız.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Diziler, verilerinizin öbek yerine <strong>stack</strong> <em>(Bundan böyle yığın olarak bahsedilecektir)</em> üzerinde depolanmasını(<a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">Yığın ve öbek konusunu 4. bölümde inceleyeceğiz</a><!-- ignore -->) veya daima belli sayıda öğelere sahip olmak istediğiniz hallerde yararlıdır. Yine de diziler, vektörler kadar esnek değildir. Standart kitaplık tarafından sağlanan vektörler diziyle benzeşen ancak boyutları değişebilen koleksiyon türleridir. Bunlardan hangisini kullanacağınızdan emin olamadığınız durumlarda olasılıkla bir vöktör türüne ihtiyacınız vardır. <a href="ch08-01-vectors.html">Vektörleri</a><!-- ignore -->  8. bölümde tartışıyor olacağız.</p>
<p>Diziler eleman sayısının değişmeyeceği bilinen durumlarda kullanışlıdır. Eğer ayların isimlerini kullanan bir kod yazıyor olsaydınız başka bir ayın girip çıkması mümkün olmayan ve daima 12 elemandan oluşan bir listeniz olacağından vektör yerine dizi kullanmayı tercih ederdiniz.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let aylar = [&quot;Ocak&quot;, &quot;Şubat&quot;, &quot;Mart&quot;, &quot;Nisan&quot;, &quot;Mayıs&quot;, &quot;Haziran&quot;,
             &quot;Temmuz&quot;, &quot;Ağustos&quot;, &quot;Eylül&quot;, &quot;Ekim&quot;, &quot;Kasım&quot;, &quot;Aralık&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Bir dizinin türü köşeli parantez kullanılarak yazılır. Bu parantezin içinde aşağıdaki örneğe benzer biçimde, önce öğelerin türü, sonra noktalı virgül ve ardından dizide depolanacak eleman adedi belirtilir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Parantez içindeki <code>i32</code> depolanacak elemanların türünü, noktalı virgülden sonraki 5 rakamı ise dizinin beş öğeden oluşacağını gösterir.</p>
<p>Aşağıda gösterildiği gibi aynı değerlerden oluşan bir diziyi köşeli parantezlerin içine önce başlangıç değerini, ardından bir noktalı virgül ve son olarak dizide bu değerden kaç tane olacağını belirten uzunluk değerini girerek bildirebilirsiniz: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p>Örnekteki <code>a</code> dizisi değeri 3 olan 5 öğeden oluşmaktadır. Bu gösterim <code>let a = [3, 3, 3, 3, 3];</code> şeklinde yazılacak kodun aynısı olup daha kısa ve özlü biçimdeki ifadesidir.</p>
<h5 id="dizi-Öğelerine-erişim"><a class="header" href="#dizi-Öğelerine-erişim">Dizi Öğelerine Erişim</a></h5>
<p>Dizi, yığın üzerinde depolanan tek bir bellek bloğudur. Dizi öğelerine aşağıda gösterildiği gibi dizin numaralarını kullanarak erişebilirsiniz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let birinci = a[0];
    let ikinci  = a[1];
}
</code></pre></pre>
<p>örnekteki <code>birinci</code> değişkeni, dizinin indeks başlangıcı olan [0] pozisyonunda <code>1</code> değeri bulunduğundan <code>1</code> değerini, <code>ikinci</code>adındaki değişkense <code>[1]</code> pozisyonunda <code>2</code> değeri bulunduğundan <code>2</code> değerini alacaktır.</p>
<h5 id="geçersiz-dizi-Öğesine-erişmek"><a class="header" href="#geçersiz-dizi-Öğesine-erişmek">Geçersiz Dizi Öğesine Erişmek</a></h5>
<p>Dizi sınırları dışında kalan bir öğe numarasına erişmek isterseniz ne olur? 2. Bölümdeki sayı tahmin oyununa benzer bir kod kullanan aşağıdaki örneği kullanıcıdan bir dizin numarası alacak şekilde değiştirdiğimizi varsayalım: </p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Lütfen bir dizin numarası giriniz:&quot;);

    let mut dizin = String::new();

    io::stdin()
        .read_line(&amp;mut dizin)
        .expect(&quot;Satır okunamadı&quot;);

    let dizin: usize = dizin
        .trim()
        .parse()
        .expect(&quot;Girilen dizin numarası bir sayı olmalıdır.&quot;);

    let öğe = a[dizin];

    println!(
        &quot;dizin {}'de bulunan öğe değeri: {}&quot;,
        dizin, öğe
    );
}
</code></pre></pre>
<p>Bu kod <code>cargo run</code> komutuyla çalıştırdığınızda başarıyla derlenecektir. Program çalıştırdığınızda sizden istenilen dizin numarasını 0, 1, 2, 3, 4 olarak girerseniz o dizin numarasına karşılık gelen değer yazdırılır. Fakat dizi boyutunu aşan 5 veya 10 gibi bir değer girerseniz aşağıdaki gibi bir çıktı alırsınız:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Program dizin numarasında geçersiz bir değer kullanıldığında bir çalışma zamanı hatası ve hatayı içeren bir mesaj eşliğinde sonlanarak en alt satırdaki <code>println!</code> ifadesini yürütmez. Bir öğeye dizin numarası kullanarak erişmeye çalıştığınızda Rust, belirtilen dizin numarasının dizi uzunluğundan daha az olup olmadığını kontrol eder. Dizin numarası dizi uzunluğuna eşit veya büyükse programın çalıştırılması panik yoluyla sonlandırılır. Programın çalışması sırasında elde edilecek verilerin kontrol edilmesini gerektiren senaryolarda derleyicinin, kullanıcı tarafından hangi dizin numarasının girildiğine dair bir fikri olamayacağından bu tür kontrol ve denetimlerin çalışma zamanında yapılması gerekir. </p>
<p>Bu senaryo Rust'ın bellek güvenliği ilkelerinin uygulamadaki örneğidir. Böyle bir denetim pekçok düşük seviyeli programlama dilinde genellikle yapılmadığından hatalı bir dizin numarasıyla yapılan işlem sonucu geçersiz belleğe erişilir. Ancak Rust, bellek erişimine izin vermek yerine çalışmayı durdurarak sizi bu tür hatalara karşı korur. Rust'ın <a href="h09-00-error-handling.html">hata işleme yöntemlerine</a> 9. Bölümde değineceğiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="İşlevler"><a class="header" href="#İşlevler">İşlevler</a></h2>
<p>İşlevler Rust kodlarında yaygın olarak kullanılır. Dildeki en önemli işlevlerden biri olan ve programın giriş noktasını oluşturan <code>main</code> ile, yeni bir işlev bildirmeye yarayan <code>fn</code> anahtar sözcüğünü daha önce görmüştünüz.</p>
<p>Rust geleneksel olarak değişken ve işlev isimlerinde küçük harflerden oluşan ve ayrı kelimelerin alt çizgi ile birbirine bağlandığı <em>snake_case</em> tarzını kullanmaktadır.</p>
<p>Aşağıdaki programda bir işlev tanımı örneklenmektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Merhaba dünya!&quot;);

    başka_işlev();
}

fn başka_işlev() {
    println!(&quot;Bir başka işlev.&quot;);
}
</code></pre></pre>
<p>Rust'ta bir işlevi <code>fn</code> anahtar kelimesi ardından işlev adı ve bir parantez seti ile tanımlarız. Süslü parantezlerin konumu derleyiciye işlevin nerede başlayıp nerede bittiğini bildirir.</p>
<p>Halihazırda tanımlı olan bir işlev ise adı ve arkasına gelen parantez seti ile çağırılır. Örneğimizde <code>başka_işlev</code> zaten tanımlı olduğundan <code>main</code> işlevi içinden çağırılabilmektedir. Kaynak kodumuzdaki <code>başka_işlev</code>'i <code>main</code> işlevinden <em>sonra</em> tanımladığımıza dikkat edin. Rust işlevlerin nerede tanımlandığıyla ilgilenmediğinden dilerseniz işlevlerinizi <code>main</code> işlevinden önce de tanımlayabilirsiniz.</p>
<p>İşlevlere daha yakından bakabilmek için cargo new komutu kullanarak projeler dizininde <em>islevler</em> adlı yeni bir proje başlatın. Arkasından <code>başka_işlev</code> örneğini <em>src/main.rs</em>  içine alarak kodunuzu çalıştırın. Ekranınızda aşağıdaki çıktıyı görnelisiniz:</p>
<pre><code class="language-console"> $ cargo run                                                                                                                          ✔
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.67s
     Running `target/debug/islevler`
Merhaba dünya!
Bir başka işlev.
</code></pre>
<p>Satırlar <code>main</code> işlevinde göründüğü sırayla işletilir. İlk olarak &quot;Merhaba dünya!&quot; mesajı, arkasından <code>başka_işlev</code> çağrısının ürettiği &quot;Bir başka işlev.&quot; mesajı yazdırılır. </p>
<h3 id="parametreler"><a class="header" href="#parametreler">Parametreler</a></h3>
<p>İşlevleri, işlev imzasına ait özel değişkenler olan parametreler ile birlikte tanımlayabiliriz. Bir işlevde parametreler bulunuyorsa bu parametrelere somut değerler iletebilirsiniz. İşlevlere parametre olarak iletilen somut değerler argüman aolarak adlandırılır. Fakat insanlar konuşmalarında bu kavramları kullanırken, işlev tanımındaki değişkenleri anlatan <em>parametre</em> yerine argüman, işlev çağrısı esnasında iletilen somut değerleri temsil eden <em>argüman</em> yerine parametre olarak bahsetmekte veya tam tersi biçimde birbirinin yerine geçirerek kullanma eğilimindedirler. </p>
<p>Aşağıda <code>başka_işlev</code>'in şimdiki sürümüne bir parametre ekliyoruz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    başka_işlev(5);
}

fn başka_işlev(x: i32)  {
     println!(&quot;X'in değeri: {}&quot;, x);
}
</code></pre></pre>
<p>Programı çalıştırdığınızda aşağıdaki çıktıyı alıyor olmalısınız:</p>
<pre><code class="language-console">$ cargo run                                                                                                                          ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/islevler`
X'in değeri: 5
</code></pre>
<p>Artık <code>başka_işlev</code>'in <code>x</code> adında ve <code>i32</code> türünde bir parametresi vardır. Bu işleve 5 değeri iletildiğinde <code>println!</code> makrosu bu değeri biçimlendirme dizgisindeki süslü parentezlerin olduğu yere koyar.</p>
<p>İşlev imzalarında bulunan her parametrenin türü <em>mutlaka</em> bildirilmelidir. Bu Rust tasarlanırken alınan bilinçli bir karardır. İşlev  tanımlarında tür bildirimi zorunluluğu, derleyicinin kullanılacak türü kodun başka bir yerinde kullanılmadan anlamasını sağlar.</p>
<p>Tanımlanan parametre sayısı birden fazlaysa bildirimlerin arası aşağıdaki gibi virgül ile ayrılmalıdır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    etiket_değerlerini_yazdır(5, 'h');
}

fn etiket_değerlerini_yazdır(değer: i32, birim: char) {
    println!(&quot;Etiket değerleri: {}{}&quot;, değer, birim);
}
</code></pre></pre>
<p>Bu örnek iki parametresi bulunan <code>etiket_değerlerini_yazdır</code> adlında bir işlev oluşturur. İşlevin <code>değer</code> adındaki ilk parametresi <code>i32</code>, <code>birim</code> adındaki ikinci parametresiyse <code>char</code> türündedir. Bu işlev <code>değer</code> ve <code>birim</code> verilerini içeren bir metin yazdırır. </p>
<p>Bu kodu islevler adlı projenizin <em>src/main.rs</em> dosyasında bulunan bir önceki kodla değiştirdikten sonra <code>cargo run</code> komutunu kullanarak çalıştırın:</p>
<pre><code class="language-console">$ cargo run                                                                                                      ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/islevler`
Etiket değerleri: 5h
</code></pre>
<p>İşlevi <code>değer</code> verisi için <code>5</code>, <code>birim</code> verisi için <code>h</code> ile çağırdığımızdan dolayı program çıktısı bu değerleri içermektedir. </p>
<h3 id="deyimler-ve-İfadeler"><a class="header" href="#deyimler-ve-İfadeler">Deyimler ve İfadeler</a></h3>
<!-- 
Ç.N: 
Statement: değerli ifade anlamında 
Expression: emire daha yakın ifade anlamında
statementler değer taşırken expression bir iş yapar.
-->
<p>İşlev gövdeleri isteğe bağlı olarak bir ifadeyle biten deyimlerden oluşur. Her ne kadar şu ana kadar gördüğünüz işlevler bitiş ifadesi içermiyor olsa da deyimin bir parçası olan ifadeyle karşılaştınız. Rust ifade tabanlı bir dil olduğundan bu ayrıntının anlaşılması önemlidir. Bu ayrım diğer dillerde olmadığından deyim ve ifadenin ne olduğuna ve farklarının işlev gövdelerini nasıl etkilediğini inceleyelim.</p>
<p><em>Deyimler</em> bazı eylemleri gerçekleştiren ve bir değer döndürmeyen talimatlarken, <em>ifadeler</em> sonuç olarak bir değer döndürürler. </p>
<p>Zaten deyim ve ifadeleri daha önce kullanmıştık. Örneğin <code>let</code> anahtar sözcüğüyle değişken oluşturarak ona değer atamak ve Örnek 3-1'deki <code>let y = 6</code> talimatı birer deyimdir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption"> Örnek 3-1: Deyimden içeren bir <code>main</code> işlevi</span></p>
<p>Tıpkı bu örneğin tamamı gibi işlev tanımları da kendi içinde birer deyimdir.</p>
<p>Aşağıdaki kodda yapıldığı gibi <code>let</code> deyimini bir başka değişkene atamaya kalktığınızda, deyimler değer döndürmedikllerinden hata almanız kaçınılmazdır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>Bu programı çalıştırdığınızda aşağıdaki gibi bir hata alacaksınız:</p>
<pre><code class="language-console">cargo run                                                                                                                          ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
error: expected expression, found statement (`let`)
  --&gt; src/main.rs:41:14
   |
41 |     let x = (let y = 6);
   |              ^^^^^^^^^
   |
   = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are experimental
  --&gt; src/main.rs:41:14
   |
41 |     let x = (let y = 6);
   |              ^^^^^^^^^
   |
   = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
   = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

warning: unnecessary parentheses around assigned value
  --&gt; src/main.rs:41:13
   |
41 |     let x = (let y = 6);
   |             ^         ^
   |
   = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
   |
41 -     let x = (let y = 6);
41 +     let x = let y = 6;
   | 

For more information about this error, try `rustc --explain E0658`.
warning: `islevler` (bin &quot;islevler&quot;) generated 1 warning
error: could not compile `islevler` due to 2 previous errors; 1 warning emitted
</code></pre>
<p>Burada <code>let y = 6</code> deyimi bir değer döndürmeyeceğinden <code>x</code>'in bağlanacağı bir değer yoktur. Bu durum böyle bir atamanın atanan değeri döndürdüğü C ve Ruby gibi dillerden farklıdır. Bahsedilen dillerde <code>x = y = 6</code> şeklide bir talimatla hem <code>x</code> hem de <code>y</code> değişkenlerine <code>6</code> değerini atayabilirsiniz. Ancak Rust'ta durum böyle değildir.</p>
<p>İfadeler ise değer olarak hesaplanır ve Rust'ta yazacağınız kodların çoğunluğu ifadelerden oluşacaktır. Bunu <code>11</code> sonucunu veren <code>5 + 6</code> matematiksel işlemiymiş gibi düşünün. İfadeler deyimlerin bir parçası olabilir. Örnek 3-1'de yer alan <code>let y = 6</code> deyimindeki <code>6</code>'nın, işletildiğinde <code>6</code> olarak değerlendirilmesi gibi işlev çağrıları da birer ifadedir. Tıpkı makro çağrılarının birer ifade olması gibi süslü parantezlerle oluşturulan kapsam blokları da birer ifadedir. Örneğin: </p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;Y'nin değeri: {}&quot;, y);
}
</code></pre></pre>
<p>Burada:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p><code>let</code> deyiminin parçası olan ve <code>4</code> olarak değerlendirilen blok bir ifadedir. Bu değer <code>let</code> deyiminin bir parçası olduğundan <code>y</code> değişkenine bağlanır. Şimdiye kadar gördüğünüz çoğu satırın aksine <code>x + 1</code> satırının sonunda noktalı virgülün olmadığına dikkat edin. İfadeler noktalı virgül ile sonlanmaz. Eğer bu ifadenin sonuna noktalı virgül eklerseniz onu değer döndürmeyen bir deyime dönüştürürsünüz. Bunu, bir sonraki konuda dönüş değerleri ve ifadeleri incelerken aklınızda bulundurun.</p>
<h3 id="değer-döndüren-İşlevler"><a class="header" href="#değer-döndüren-İşlevler">Değer Döndüren İşlevler</a></h3>
<p>İşlevler kendilerini çağıran koda değer döndürebilirler. Dönüş değerleri isimlendilmez fakat türleri bir oku (<code>-&gt;</code>) takiben bildirilir. Rust'ta işlevin dönüş değeri, işlev gövdesindeki son ifadenin değeriyle aynıdır. İşlevden erken çıkabilmek için dönüş değeri eşliğinde <code>return</code> anahtar sözcüğünü kullanabilirsiniz, ancak pekçok işlev son ifadeyi örtük biçimde döndürür. Aşağıda değer döndüren bir işlev örneği verilmektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn beş() -&gt; i32 {
    5
}

fn main() {
    let x = beş();

    println!(&quot;X'in değeri: {}&quot;, x);
}
</code></pre></pre>
<p><code>Beş</code> işlevinde <code>5</code> rakamı hariç hiçbir işlev çağrısı, makro ve <code>let</code> deyimi yoktur. Ve bu Rust'ta tamamen geçerli bir işlevdir. İşlev dönüş türünün <code>-&gt; i32</code> olarak belirtildiğine dikkat edin. Bu kodu çalıştırdığınızda aşağıdaki gibi çıktı üretmelidir:</p>
<pre><code class="language-console">$ cargo run                                                                                                                          ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
    Finished dev [unoptimized + debuginfo] target(s) in 1.25s
     Running `target/debug/islevler`
X'in değeri: 5
</code></pre>
<p>İşlevin dönüş değeri <code>5</code> olduğundan dönüş türü de <code>i32</code> olarak ayarlanmıştır. İşlevi dikkatle incelediğimizde iki şeyle karşılaşırız. İlki olarak <code>let x = beş();</code> satırı, <code>x</code> değişkenini başlatmak için işlevin dönüş değerinden yararlandığımızı anlatır. <code>Beş</code> işlevi <code>5</code> değerini döndürdüğünden o satır aşağıdakiyle aynı anlama gelir.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>İkinci olarak, <code>beş</code> işlevi parametresiz olmamasına rağmen döndürülecek değerin türünü tanımlar. Bununla birlikte işlev gövdesi döndürmek istediğimiz değeri ifade ettiğinden noktalı virgül olmadan tek bir <code>5</code>'ten oluşur.</p>
<p>Başka bir örneği inceleyelim:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = artı_bir(5);

    println!(&quot;X'in değeri: {}&quot;, x);
}

fn artı_bir(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Bu kodu çalıştırdığınızda <code>X'in değeri: 6</code> sonucunu yazdıracaktır. Ama <code>x + 1</code>'in bulunduğu satır sonuna onu bir ifadeden deyime çeviren noktalı virgül eklerseniz hata ile karşılaşırsınız:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = artı_bir(5);

    println!(&quot;X'in değeri: {}&quot;, x);
}

fn artı_bir(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Bu kod derlendiğinde aşağıdaki benzer şekilde hata üretecektir:</p>
<pre><code class="language-console">$ cargo run                                                                                                                          ✔ 
   Compiling islevler v0.1.0 (/home/rusdili/projeler/islevler)
error[E0308]: mismatched types
  --&gt; src/main.rs:84:24
   |
84 | fn artı_bir(x: i32) -&gt; i32 {
   |    --------            ^^^ expected `i32`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
85 |     x + 1;
   |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
</code></pre>
<p>Hatayı özetleyen “mismatched types” (uyumsuz türler) mesajı bize bu kodunun temel sorununu göstermektedir. <code>artı_bir</code> işlev tanımı <code>i32</code> türünde bir değer döndürüleceğini bildirirken artık bir deyim olan ve birim türü <code>()</code> olarak temsil edilen satır bir değer olarak değerlendirilemez. Bu nedenle işlev tanımıyla çelişen ve bir hatayla sonuçlabilecek hiçbir şey döndürülmez. Rust hata raporunda noktalı virgülün kaldırılmasını öneren bir mesajla sorunun çözülmesine yardım eder.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yorumlar"><a class="header" href="#yorumlar">Yorumlar</a></h2>
<p>Tüm geliştiriciler kodlarının kolay anlaşılmasını isterler. Ancak bunu sağlamak için bazen kodun içine ek açıklamalar yazmak gerekir. Böyle durumlarda kaynak kodun içinde, derleyicinin görmezden geleceği fakat kodu okuyanlar için faydalı olabilecek <em>yorumlar</em> bırakılır.</p>
<p>Basit bir yorum örneği:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Merhaba dünya!
<span class="boring">}
</span></code></pre></pre>
<p>Rust'ta klasik yorumlar iki eğik çizgiyle başlar ve satır sonuna kadar devam eder. Bir satırdan daha uzun süren yorumlar için örnekte gösterildiği gibi her satır için eğik <code>//</code> çizgi eklemeniz gerekir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Burada karmaşık bir şey yok. Bu kod sadece bir satıra sığmayacak kadar uzun olan
// ve alt satıra geçen yorum satırlarını örneklemek için oluşturulmuş bir kod parçasıdır.
// Kolaylıkla anlaşılabilir olduğunu umuyorum...
<span class="boring">}
</span></code></pre></pre>
<p>Yorumlar kodun bulunduğu satır sonuna da eklenebilirler:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let şanslı_numaram = 7; // Bugün kendimi şanslı hissediyorum!
}
</code></pre></pre>
<p>Ancak bazen açıklamalanın aşağıda örneklendiği gibi açıkladığı kodun üzerindeki satırda yer aldığını göreceksiniz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Bugün kendimi şanslı hissediyorum!
    let şanslı_numaram = 7;
}
</code></pre></pre>
<p>Rust'ın ayrıca &quot;Bir Sandığı Cretes.io'da Yayınlamak&quot; adlı 14. Bölümünde inceleyeceğimiz kodun belgelenmesini sağlayan başka bir yorum türü daha bulunmaktadır.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kontrol-akışı"><a class="header" href="#kontrol-akışı">Kontrol Akışı</a></h2>
<p>Bir kodun doğruluğuna bağlı olarak kodun başka bir bölümünün çalıştırılması veya bazı kodların bir koşul doğru olduğu sürece çalıştırılması çoğu programlama dilinin temel yapı taşlarıdır. Rust'ta kod yürütme akışını kontrol edebilmenizi sağlayan en yaygın kontrol yapıları <code>if</code> ifadeleri ve <code>loop</code> döngüleridir.</p>
<h3 id="if-İfadeleri"><a class="header" href="#if-İfadeleri"><code>if</code> İfadeleri</a></h3>
<p><code>If</code> ifadesi kodunuzu koşullara göre bölerek yürütmenize olanak sağlar. Bir koşul belirleyip ardından &quot;Bu şart sağlanırsa şu kod bloğunu çalıştırın, koşul sağlanmıyorsa çalıştırmayın.&quot; demeye benzer.</p>
<p><code>If</code> ifadesini daha iyi kavrayabilmek için <em>projeler</em> dizininde <em>dallar</em> adında yeni bir proje oluşturup <em>src/main</em> dosyasına aşağıdaki kodları ekleyin: </p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sayı = 3;

    if sayı &lt; 5 {
        println!(&quot;Koşul doğru.&quot;);
    } else {
        println!(&quot;Koşul yanlış!&quot;);
    }
}
</code></pre></pre>
<p>Tüm <code>if</code> ifadeleri, <code>if</code> anahtar kelimesiyle başlar ve bunu bir koşul takip eder. Örneğimizdeki koşul <code>sayı</code> değişkeninin 5'ten küçük olup olmadığını kontrol eder. Koşulun <code>true</code> (doğru) olması durumunda yürütülecek kod bloğu koşulun hemen ardından eklenen süslü parantezler içine yerleştirilir. <code>If</code> ifadesinin koşulunu denetleyen kod blokları, kitabın 2. Bölümündeki <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">Tahmin Sayısının Gizli Sayı ile Karşılaştırılması</a><!-- ignore -->  konusunda yer alan eşleme ifadesinde olduğu gibi bazen kol bazen dal olarak adlandırılabilir.</p>
<p>Dilerseniz örnekte yaptığımız gibi, koşulun <code>false</code> (yanlış) olması halinde alternatif bir kod bloğu olarak işletilecek bir <code>else</code> ifadesini de kodunuza ekleyebilirsiniz. Eğer koşul yanlış ve bir <code>else</code> ifadesi bildirilmemişse program <code>if</code> bloğunu geçerek sonraki kod parçasına atlayacaktır.</p>
<p>Kodu çalıştırdığınızda aşağıdaki çıktıyı görmelisiniz:</p>
<pre><code class="language-console">$ cargo run                                                                                                                            ✔
   Compiling dallar v0.1.0 (/home/rusdili/projeler/dallar)
    Finished dev [unoptimized + debuginfo] target(s) in 1.82s
     Running `target/debug/dallar`
Koşul doğru.
</code></pre>
<p>Ne olacağını görmek için <code>sayı</code> değerini, koşulu <code>false</code> yapacak bir değerle değiştirelim:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let sayı = 7;
<span class="boring">
</span><span class="boring">    if sayı &lt; 5 {
</span><span class="boring">        println!(&quot;Koşul doğru.&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;Koşul yanlış!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Ve programı yeniden çalıştırıp çıktıyı inceleyin:</p>
<pre><code class="language-console">$ cargo run                                                                                                                            ✔ 
   Compiling dallar v0.1.0 (/home/rusdili/projeler/dallar)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/dallar`
Koşul yanlış!
</code></pre>
<p>Bu koddaki koşulun bir <code>bool</code> olması gerektiğini belirtmekte yarar var. Koşulun <code>bool</code> olmaması halinde hata ile karşılaşırız. Örnekteki kodu çalıştırmayı deneyin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let sayı = 3;

    if number {
        println!(&quot;Sayı üç&quot;);
    }
}
</code></pre>
<p>Artık <code>if</code> koşulu 3 değerine ayarlanmış olduğundan Rust bir hata döndürecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling dallar v0.1.0 (/home/rusdili/projeler/dallar)
error[E0308]: mismatched types
  --&gt; src/main.rs:29:8
   |
29 |     if sayı {
   |        ^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `dallar` due to previous error
</code></pre>
<p>Bu hata bize, Rust'ın <code>bool</code> türünde bir değer beklediğini ancak tam sayı türünde değer aldığını gösterir. Ruby veya Javascript gibi dillerin tersine Rust, boolean olmayan türleri otomatik olarak boolean türüne dönüştürmeye kalkışmaz. Açık olmanız ve <code>if</code> koşulunun daima boolean olmasını sağlamanız gerekir. Örneğin sayı <code>0</code> olmadıkça <code>if</code> kod bloğunun yürütülmesini istiyorsak, <code>if</code> ifadesini aşağıdaki gibi değiştirebiliriz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sayı = 3;

    if sayı != 0 {
        println!(&quot;Bu sayı sıfır değil!&quot;);
    }
}
</code></pre></pre>
<p>Bu kod çalıştırıldığında ekrana <code>Bu sayı sıfır değil!</code> mesajını yazdıracaktır.</p>
<h4 id="else-if-ile-koşulları-İşlemek"><a class="header" href="#else-if-ile-koşulları-İşlemek"><code>else if</code> ile Koşulları İşlemek</a></h4>
<p>Bir <code>else if</code> ifadesinde <code>if</code> ve <code>else</code> kelimelerini birleştirerek çok sayıda koşulu denetleyebilirsiniz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sayı = 6;

    if sayı % 4 == 0 {
        println!(&quot;Sayı 4' e kalansız bölünebilir.&quot;);
    } else if sayı % 3 == 0 {
        println!(&quot;Sayı 3' e kalansız bölünebilir.&quot;);
    } else if sayı % 2 == 0 {
        println!(&quot;Sayı 2' ye kalansız bölünebilir.&quot;);
    } else {
        println!(&quot;Sayı 4, 3 veya 2'ye kalansız bölünemez!&quot;);
    }
}
</code></pre></pre>
<p>Bu programın gidebileceği dört olası yol vardır. Progamı çalıştırdığınızda aşağıdaki çıktıyı görmelisiniz:</p>
<pre><code class="language-console">$ cargo run
   Compiling dallar v0.1.0 (/home/rusdili/projeler/dallar)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/dallar`
Sayı 3' e kalansız bölünebilir.
</code></pre>
<p>Program yürütüldüğünde <code>if</code> ifadelerinin her birini sırayla kontrol edecek ve bulduğu ilk doğru koşulu işletecektir. 6 sayısının 2'ye kalansız bölünüyor olmasına rağmen, çıktıda <code>Sayı 2' ye kalansız bölünebilir.</code> mesajını veya <code>else</code> bloğunda yer alan <code>Sayı 4, 3 veya 2'ye kalansız bölünemez!</code> mesajını görmediğimize dikkat edin. Bunun nedeni Rust'ın kontrol sırasındaki ilk doğru koşulu bularak onu işletmesi ve diğer koşulların doğu olup olmamasıyla ilgilenmemesidir. </p>
<p>Çok sayıda <code>else if</code> ifadesi kullanmak kodunuzu karıştırabilir. Gereğinden fazla <code>else if</code> ifadesi kullandığınızı düşünüyorsanız kodunuzu yeniden düzenlemelisiniz. Kitabın 6. bölümünde böyle durumlarda kullanabileceğiniz güçlü bir dallanma yapısına sahip <code>match</code>  (eşleme) adlı bir yapı anlatılır. </p>
<h4 id="bir-let-deyiminde-if-kullanmak"><a class="header" href="#bir-let-deyiminde-if-kullanmak">Bir <code>let</code> Deyiminde <code>if</code> Kullanmak</a></h4>
<p>Örnek 3-2'de olduğu gibi <code>if</code>'in bir ifade olması, sonucunun herhangi bir değişkene atanmak üzere <code>let</code> deyiminin sağ tarafında kullanabilmesni sağlar.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let koşul = true;
    
    let sayı = if koşul {5} else {6};
    
    println!(&quot;Sayının değeri : {}&quot;, sayı);
}
</code></pre></pre>
<p><span class="caption"> Örnek 3-2: Bir <code>if</code> ifadesi sonucunu değişkene atamak.</span></p>
<p><code>Sayı</code> değişkeni <code>if</code> ifadesinin sonucuna göre oluşan bir değere bağlanacaktır. Bu kodu çalıştırdığınızda aşağıdaki çıktıyı elde edeceksiniz:</p>
<pre><code class="language-console">$ cargo run
   Compiling dallar v0.1.0 (/home/rusdili/projeler/dallar)
    Finished dev [unoptimized + debuginfo] target(s) in 1.36s
     Running `target/debug/dallar`
Sayının değeri: 5
</code></pre>
<p>Kod bloklarının, içlerinde bulunan son ifadeyi değerlendirdiğini ve sayıların da birer ifade olduğunu unutmayın. Bizim durumumuzda tüm <code>if</code> ifadesinin değeri yürütülecek olan kod bloğunun değerine bağlıdır. Bu da, <code>if</code> ifadesindeki sonuç üretme potansiyeline sahip her dalın aynı türden olması gerektiği anlamına gelmektedir. Örnek 3-2'de bulunan <code>if</code> ve <code>else</code> dallarının her biri <code>i32</code> türünde birer tam sayıdır. Aşağıdaki örnekten de anlaşılacağı gibi, türlerin uyumsuz olması hata alınmasına neden olur:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let koşul = true;

    let sayı = if koşul {5} else { &quot;Altı&quot; };

    println!(&quot;Sayının değeri: {}&quot;, sayı);
}
</code></pre>
<p>Kodu derlemeye çalıştığımızda <code>if</code> ve <code>else</code> kollarının uyumsuz türlerden oluştuğu ve bu hatanın hangi satırda bulunduğunu gösteren bir hata raporuyla karşılaşırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling dallar v0.1.0 (/home/rusdili/projeler/dallar)
error[E0308]: `if` and `else` have incompatible types
  --&gt; src/main.rs:70:36
   |
70 |     let sayı = if koşul {5} else { &quot;Altı&quot; };
   |                          -         ^^^^^^ expected integer, found `&amp;str`
   |                          |
   |                          expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `dallar` due to previous error
</code></pre>
<p><code>If</code> bloğundaki ifade tam sayı olarak değerlendirilirken <code>else</code> bloğundaki ifadeyse dizgi olarak olarak değerlendirilecektir. Değişkenlerin aynı türden olması ve <code>sayı</code> değişkeni türünün Rust tarafından derleme zamanında kesinlikle biliniyor olması gerektiğinden bu kod işe yaramaz. <code>Sayı</code> türünün derleme zamanında biliniyor olması, bu değişkenin kullanıldığı her yerde, derleyici tarafından türünün doğru ve geçerli olduğunun garantilenmesini sağlar. Eğer <code>sayı</code> değişkeninin türü sadece çalışma zamanında belirlenmiş olsaydı; herhangi bir değişken için çok sayıda varsayımsal türün takip edilmesi gerekecek, buna bağlı olarak derleyici karmaşıklaşacak ve kod hakkında daha az garanti verebileceğinden Rust bunu yapamamış olacaktı.</p>
<h3 id="döngüler-ile-tekrarlama"><a class="header" href="#döngüler-ile-tekrarlama">Döngüler ile Tekrarlama</a></h3>
<p>Bazen bir kod bloğunu defalarca çalıştırmak gerekir. Rust bu amaçla döngü gövdesi içinde kalan kodun tamamını çalıştırıp hemen ardından yeniden baştan başlatan çeşitli <em>döngüler</em> sağlar. Döngülerle çalışabilmek için <em>projeler</em> dizininde <em>donguler</em> adında yeni bir proje başlatalım.</p>
<p>Rust'ta <code>loop</code>, <code>while</code> ve <code>for</code> olmak üzere üç çeşit döngü vardır. Bunların her birini birlikte deneyelim:</p>
<h4 id="loop-ile-kod-tekrarı"><a class="header" href="#loop-ile-kod-tekrarı"><code>loop</code> ile Kod Tekrarı</a></h4>
<p>Bir anahtar sözcük olan <code>loop</code> Rust'a, ait olduğu kod bloğunu sonsuza dek ya da siz onu açıkça durdurana kadar tekrar tekrar çalıştırmasını söyler. Şimdi <em>donguler</em> dizinindeki <em>src/main.rs</em> dosyasını örnektekine benzer şekilde değiştirin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;Tekrar!&quot;);
    }
}
</code></pre>
<p>Programı çalıştırdığınızda terminalinizi elle kapatana kadar <code>Tekrar!</code> mesajının yazdırıldığını göreceksiniz. Pekçok terminal sonsuz döngüye kapılan programların sonlandırılmasını sağlayan <span class="keystroke">ctrl+c</span> klavye kısa yolunu destekler. Demeyelim:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling donguler v0.1.0 (/home/rusdili/projeler/donguler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/donguler`
Tekrar!
Tekrar!
Tekrar!
Tekrar!
^CTekrar!
</code></pre>
<p><code>^C</code> işareti <span class="keystroke">ctrl-c</span> tuşuna bastığınız yeri gösterir. <code>^C</code>'den sonra <code>Tekrar!</code> yazısını görmeniz, kodun kesme sinyalini aldığında döngünün neresinde bulunduğuna bağlı olduğundan bu mesajı göremeyebilirsiniz.</p>
<p>Neyse ki Rust, bu tür döngülerden kod kullanarak çıkmanın bir yolunu sağlar. Programa işletilen döngünün durdurulacağı yeri, o noktaya bir <code>break</code> anahtar sözcüğü yerleştirerek bildirebilirsiniz. Bu yöntemi 2. Bölümdeki <a href="ch02-00-guessing-game-tutorial.html#dogru-tahmin-s%C4%B1nrasi-oyundan-cikmak">“Doğru Tahmin Sonrası Oyundan Çıkmak”</a><!-- ignore --> bölümünden hatırlayor olmanız gerek.</p>
<p>Yine hatırlayacağınız gibi tahmin oyunu programında, döngünün o anki tekrarını durdurup bir sonraki tekrara atlayan <code>continue</code> anahtar kelimesini de kullanmıştık. </p>
<p>İçiçe döngüler söz konusu olduğunda <code>break</code> ve <code>continue</code> anahtar kelimeleri en içteki döngüye uygulanır. Dilerseniz döngü üzerinde daha sonra <code>break</code> ya da <code>continue</code> ile kullanabileceğiniz bir <em>döngü etiketi</em> bildirebilirsiniz. Bu durumda <code>break</code> ve <code>continue</code> anahtar kelimeleri en içteki döngüye değil etiketlenen döngüye uygulanırlar. Aşağıda iki adet içiçe geçmiş döngü örneği yer almaktadır:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut sayaç = 0;

    'saydır: loop {
        println!(&quot;sayaç: {}&quot;, sayaç);
        let mut kalan = 10;

        loop {
            println!(&quot;Kalan: {}&quot;, kalan);
            if kalan == 9 {
                break;
            }
            if sayaç == 2 {
                break 'saydır;
            }
            kalan -= 1;
        }
        sayaç += 1;
    }
    println!(&quot;Sayaç durdu: {}&quot;, sayaç);
}
</code></pre></pre>
<p><code>Saydır</code> etiketine sahip olan dış döngü 0'dan 2'ye kadar sayar. Etiketsiz olan iç döngü ise 10'dan 9'a doğru geri sayım yapar. Etiketsiz olan ilk <code>break</code> yalnızca iç döngüden, <code>break 'saydır;</code> ifadesiyse dış döngüden çıkar. Bu kod aşağıdaki çıktıyı üretir:</p>
<pre><code class="language-console">$ cargo run
   Compiling donguler v0.1.0 (/home/rusdili/projeler/donguler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/donguler`
sayaç: 0
Kalan: 10
Kalan: 9
sayaç: 1
Kalan: 10
Kalan: 9
sayaç: 2
Kalan: 10
Sayaç durdu: 2
</code></pre>
<h4 id="döngülerden-değer-döndürmek"><a class="header" href="#döngülerden-değer-döndürmek">Döngülerden Değer Döndürmek</a></h4>
<p>Döngü kullanımlarından biri de, iş parçacıklarının işlerini bitirip bitirmediğinin kontrolü gibi başarısız olması muhtemel işlemleri yeniden denemektir. Hem ayrıca işlem sonucunu bu döngünün dışında kalan kod bölümüne de aktarmanız gerekebilir. Bunu yapabilmek için döngüyü döngüyü sonlandıracak olan <code>break</code> ifadesinden ardından döndürülmesini istediğiniz değeri eklemek yeterlidir. Bu değer örnekte gösterildiği gibi döngüden döndürülecektir:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut sayaç = 0;

    let sonuç = loop {
        sayaç += 1;

        if sayaç == 10 {
            break sayaç * 2;
        }
    };

    println!(&quot;Sonuç: {}&quot;, sonuç);
}
</code></pre></pre>
<p>Döngüden önce <code>sayaç</code> adında bir değişken tanımlıyarak <code>0</code> değeriyle başlatıyoruz. Hemen ardından döngüden dönecek olan değeri depolayacağımız <code>sonuç</code> değişkenini tanımlıyoruz. Döngü tekrarlandıkça sayaç değerine <code>1</code> ekleneceğinden sayacın <code>10</code>'a eşit olup olmadığını kontrol ediyor, değer <code>10</code> olduğunda <code>break</code> anahtar sözcüğüne ek olarak <code>sayaç * 2</code> değerini ekliyoruz. Döngü bitiminde değeri <code>sonuç</code> değişkenine atayacak olan ifadeyi noktalı virgül ile bitirdiğimize dikkat edin. Nihayetinde programı <code>sonuç</code> değişkenine atanan 20 değerini yazdıracak şekilde tamamlayıp bitiriyoruz.</p>
<h4 id="while-ile-koşullu-döngüler"><a class="header" href="#while-ile-koşullu-döngüler"><code>while</code> ile Koşullu Döngüler</a></h4>
<p>Programların genellikle döngü içinde bulunan koşulları değerlendirmeleri gerekir. Koşul doğru olduğu sürece çalışan döngü, koşulun yanlış olması durumunda programın <code>break</code> çağrısı sonucunda durdurulur. Bu tür bir davranışı <code>if</code>, <code>else</code> ve <code>break</code> kombinasyonlarını kullanarak uygulamak mümkündür. Eğer isterseniz bunu bir programla hemen şimdi deneyebilirsiniz. Fakat bu model o kadar yaygın biçimde kullanılmaktadır ki, Rust bunun için <code>while</code> döngüsü adında yerleşik bir dil yapısı sunar. Örnek 3-3'te geriye doğru 3 tur dönen ve her dönüşünde döngünün bulunduğu turu yazdıran, son olarak bir mesaj yazdırarak döngüden çıkan program için <code>while</code> döngüsünden yararlanıyoruz. </p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut sayı = 3;

    while sayı != 0 {
        println!(&quot;{}!&quot;, sayı);

        sayı -= 1;
    }
    println!(&quot;Görev Tamamlandı!&quot;);
}
</code></pre></pre>
<p><span class="caption">Örnek 3-3: Koşul doğru olduğu sürece çalışan kod için <code>while</code> döngüsünü kullanmak</span></p>
<p>Bu yapı, <code>loop</code>, <code>if</code>, <code>else</code> ve <code>break</code> kullanarak yazacağınız bir programda gerekli olacak çok sayıda içiçe yuvalanmayı ortadan kaldıracağı için oldukça nettir. Ve bu kod, koşul doğru olduğu sürece çalışacak aksi halde döngüden çıkacaktır.</p>
<h4 id="bir-koleksiyonu-for-döngüsüyle-dolaşmak"><a class="header" href="#bir-koleksiyonu-for-döngüsüyle-dolaşmak">Bir Koleksiyonu <code>for</code> Döngüsüyle Dolaşmak</a></h4>
<p>Dizi gibi bir koleksiyonun öğeleri üzerinde yineleme yapmak için <code>while</code> yapısını kullanmak isteyebilirsiniz. Mesela Örnek 3-4'teki döngü <code>a</code> dizisindeki tüm öğeleri yazdırır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    let mut dizin = 0;

    while dizin &lt; 5 {
        println!(&quot;Değer: {}&quot;, a[dizin]);

        dizin += 1;
    }
}
</code></pre></pre>
<p><span class="caption">Örnek 3-4: Bir koleksiyonun öğelerini <code>while</code> döngüsü kullanarak dolaşmak</span></p>
<p>Bu kod dizideki elemaları sayar. Bunu 0 dizininden başlayarak koleksiyonun sonuncu dizinine yani koşulumuz <code>dizin &lt; 5</code>'in doğru olmadığı noktaya dek döngü şeklinde tekrarlayarak yapar. Bu kod çalıştırıldığında dizideki tüm öğeler yazdırırılır:</p>
<pre><code class="language-console">$ cargo run                                                                                                                                                                      ✔ 
   Compiling donguler v0.1.0 (/home/rusdili/projeler/donguler)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `/home/rusdili/projeler/donguler/target/debug/donguler`
Değer: 10
Değer: 20
Değer: 30
Değer: 40
Değer: 50
</code></pre>
<p>Beklendiği gibi dizideki beş elemanın her biri terminalde görünür. Bir noktada <code>dizin</code> değeri <code>5</code>'e ulaşsa bile, diziden altıncı değeri alınmadan önce döngü yürütmeyi durdurur.</p>
<p>Ancak bu yaklaşım dizin değeri ya da test koşulunun yanlış olduğu hallerde hataya açık olup programın paniklemesine neden olur. Örneğin eğer a dizisini 4 elemandan oluşacak şekilde yeniden düzenler ve döngü koşulunu <code>dizin &lt; 4</code> şeklinde güncellemeyi unutursanız kodunuz panikleyecektir. Ayrıca bu tasarım derleyicinin, döngü boyunca her tekrarda koşulun dizi sınırlarını aşıp aşmadığını kontrol edecek ek çalışma zamanı kodları eklemesini gerektireceğinden yavaş kalacaktır.</p>
<p>Alternatif olarak bir koleksiyondaki her öğeyi ayrı ayrı işlemek için daha kısa ve özlü olan <code>for</code> döngüsünü kullanabilirsiniz. Bir <code>for</code> döngüsü Örnek 3-5'teki koda benzer:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for öğe in a {
        println!(&quot;Değer: {}&quot;, öğe);
    }
}
</code></pre></pre>
<p><span class="caption">Örnek 3-5: Bir koleksiyonun öğelerini <code>for</code> döngüsü kullanarak dolaşmak</span></p>
<p>Bu kodu çalıştırdığımızda Örnek 3-4'tekiyle aynı mesajları alırız. Daha da önemlisi artık kodun güvenliğini artırmış, dizi eleman sayısının ötesine geçmek ya da gereği kadar tur yapmamaktan kaynaklı bazı öğelerin işlenememesi gibi hata olasılıklarını ortadan kaldırmış olduk.</p>
<p>Hem ayrıca <code>for</code> döngüsü kullanımında dizi öğe sayısının değişmesi, Örnek 3-4'te olduğu gibi kodun yeniden güncellenmesini gerektirmez.</p>
<p>Kısa ve güvenle kullanılıyor olması <code>for</code> döngüsünün Rust'ta en yaygın kullanılan döngü yapısı olmasını sağlar. Geri sayım için <code>while</code> döngüsü kullanan Örnek 3-3'te olduğu gibi pekçok Rust geliştiricisi, belli sayıda tekrarlanacak kodlar için bile <code>for</code> döngüsünden yararlanır. Geliştiriciler bunu yaparken, belli bir başlangıç ve bitiş sayısı arasında kalan tüm sayıları sırayla üreten ve standart kitaplık tarafından sağlanan bir <code>Range</code> aralığı kullanırlar.</p>
<p>Aralığı tersine çevirebilmek içinse aşağıda gösterildiği gibi for döngüsü eşliğinde henüz görmediğimiz <code>rev</code> metodu kullanılır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for sayı in (1..4).rev() {
        println!(&quot;{}&quot;, sayı);
    }
    println!(&quot;Görev Tamamlandı!&quot;);
}
</code></pre></pre>
<p>Bu kod size daha hoş görünmüyor mu?</p>
<h2 id="Özet-2"><a class="header" href="#Özet-2">Özet</a></h2>
<p>Değişkenler, skaler ve bileşik veri türleri, işlevler, yorumlar, <code>if</code> ifadeleri ve döngüleri içeren oldukça büyük bir bölümü biigi sahibi olup bölümü tamamladınız. Burada tartışılan kavramları pekiştirmek amacıyla sonraki satırda önereceğimiz programları yazmayı deneyin.</p>
<ul>
<li>Isı değerlerini Fahrenheit ve Celsius dereceleri arasında dönüştürün.</li>
<li>Fibonacci serisindeki n. eleman değerini hesaplayın.</li>
<li>Bir noel şarkısı olan &quot;The Twelve Days of Christmas&quot;ın nakaratlarını kullanarak şarkının sözlerini yazdırın.</li>
</ul>
<p>Devam etmeye hazır olduğunuzda diğer programlama dillerinde <em>olmayan</em> Rust'ın mülkiyet kavramından bahsedeceğiz. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mülkiyeti-anlamak"><a class="header" href="#mülkiyeti-anlamak">Mülkiyeti Anlamak</a></h1>
<p>Mülkiyet kavramı Rust'ın bellek güvenliğini, çöp toplayıcıya ihtiyaç duymadan garanti etmesine yarayan ve dilin tamamını etkileyen eşsiz bir özelliktir. Bu nedenle, Rust' ta mülkiyetin nasıl çalıştığını anlamak oldukça önemlidir. Bu bölümde mülkiyetin yanı sıra bu kavramla ilişkili; borçlanma, dilimler ve Rust'ın verileri belleğe nasıl yerleştirdiğinden bahsedeceğiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mülkiyet-nedir"><a class="header" href="#mülkiyet-nedir">Mülkiyet Nedir?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referanslar-ve-borçlanma"><a class="header" href="#referanslar-ve-borçlanma">Referanslar ve Borçlanma</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dilim-türü"><a class="header" href="#dilim-türü">Dilim Türü</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="İlişkili-verileri-yapılandırmak-için-yapıları-kullanmak"><a class="header" href="#İlişkili-verileri-yapılandırmak-için-yapıları-kullanmak">İlişkili Verileri Yapılandırmak için Yapıları Kullanmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yapıları-tanımlamak-ve-Örneklemek"><a class="header" href="#yapıları-tanımlamak-ve-Örneklemek">Yapıları Tanımlamak ve Örneklemek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yapıları-kullanan-Örnek-bir-program"><a class="header" href="#yapıları-kullanan-Örnek-bir-program">Yapıları Kullanan Örnek Bir Program</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metod-sözdizimi"><a class="header" href="#metod-sözdizimi">Metod Sözdizimi</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumlar-ve-Örüntü-eşleme"><a class="header" href="#enumlar-ve-Örüntü-eşleme">Enum'lar ve Örüntü Eşleme</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bir-enum-tanımlamak"><a class="header" href="#bir-enum-tanımlamak">Bir Enum Tanımlamak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kontrol-akışı-yapısı-match"><a class="header" href="#kontrol-akışı-yapısı-match">Kontrol Akışı Yapısı match</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let-ile-Özgün-kontrol-akışı"><a class="header" href="#if-let-ile-Özgün-kontrol-akışı">if let ile Özgün Kontrol Akışı</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="büyüyen-projeleri-paketler-sandıklar-ve-modüller-ile-yönetmek"><a class="header" href="#büyüyen-projeleri-paketler-sandıklar-ve-modüller-ile-yönetmek">Büyüyen Projeleri Paketler, Sandıklar ve Modüller ile Yönetmek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paketler-ve-sandıklar"><a class="header" href="#paketler-ve-sandıklar">Paketler ve Sandıklar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kapsam-ve-gizlilik-kontrolü-İçin-modül-tanımlamak"><a class="header" href="#kapsam-ve-gizlilik-kontrolü-İçin-modül-tanımlamak">Kapsam ve Gizlilik Kontrolü İçin Modül Tanımlamak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modül-ağacındaki-bir-Öğeye-başvurmanın-yolları"><a class="header" href="#modül-ağacındaki-bir-Öğeye-başvurmanın-yolları">Modül Ağacındaki Bir Öğeye Başvurmanın Yolları</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-anahtar-kelimesi-ile-yolları-kapsama-getirmek"><a class="header" href="#use-anahtar-kelimesi-ile-yolları-kapsama-getirmek">use Anahtar Kelimesi ile Yolları Kapsama Getirmek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modülleri-farklı-dosyalara-ayırmak"><a class="header" href="#modülleri-farklı-dosyalara-ayırmak">Modülleri Farklı Dosyalara Ayırmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ortak-koleksiyonlar"><a class="header" href="#ortak-koleksiyonlar">Ortak Koleksiyonlar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="değer-listelerini-vektör-kullanarak-depolamak"><a class="header" href="#değer-listelerini-vektör-kullanarak-depolamak">Değer Listelerini Vektör Kullanarak Depolamak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utf-8-kodlu-metinleri-dizgilerle-saklamak"><a class="header" href="#utf-8-kodlu-metinleri-dizgilerle-saklamak">UTF-8 Kodlu Metinleri Dizgilerle Saklamak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="İlişkili-değerlere-sahip-anahtarları-eşleme-haritalarında-saklamak"><a class="header" href="#İlişkili-değerlere-sahip-anahtarları-eşleme-haritalarında-saklamak">İlişkili Değerlere Sahip Anahtarları Eşleme Haritalarında Saklamak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hata-yönetimi"><a class="header" href="#hata-yönetimi">Hata Yönetimi</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-ile-kurtarılamaz-hatalar"><a class="header" href="#panic-ile-kurtarılamaz-hatalar">panic! ile Kurtarılamaz Hatalar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-ile-kurtarılabilir-hatalar"><a class="header" href="#result-ile-kurtarılabilir-hatalar">Result ile Kurtarılabilir Hatalar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paniclemek-ya-da-paniclememek"><a class="header" href="#paniclemek-ya-da-paniclememek">panic!lemek ya da panic!lememek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-türler-Özellikler-ve-yaşam-süreleri"><a class="header" href="#generic-türler-Özellikler-ve-yaşam-süreleri">Generic Türler, Özellikler ve Yaşam Süreleri</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-veri-türleri"><a class="header" href="#generic-veri-türleri">Generic Veri Türleri</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Özellikler-paylaşılan-davranışı-tanımlamak"><a class="header" href="#Özellikler-paylaşılan-davranışı-tanımlamak">Özellikler: Paylaşılan Davranışı Tanımlamak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referansları-yaşam-süreleri-ile--doğrulamak"><a class="header" href="#referansları-yaşam-süreleri-ile--doğrulamak">Referansları Yaşam Süreleri ile  Doğrulamak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otomatik-testler-yazmak"><a class="header" href="#otomatik-testler-yazmak">Otomatik Testler Yazmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testler-nasıl-yazılır"><a class="header" href="#testler-nasıl-yazılır">Testler Nasıl Yazılır?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testlerin-nasıl-Çalıştırılacağını-denetlemek"><a class="header" href="#testlerin-nasıl-Çalıştırılacağını-denetlemek">Testlerin Nasıl Çalıştırılacağını Denetlemek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-organizasyonu"><a class="header" href="#test-organizasyonu">Test Organizasyonu</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bir-io-projesi-komut-satırı-programı-oluşturmak"><a class="header" href="#bir-io-projesi-komut-satırı-programı-oluşturmak">Bir I/O Projesi: Komut Satırı Programı Oluşturmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="komut-satırı-argümanlarını-kabul-etmek"><a class="header" href="#komut-satırı-argümanlarını-kabul-etmek">Komut Satırı Argümanlarını Kabul Etmek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bir-dosyayı-okumak"><a class="header" href="#bir-dosyayı-okumak">Bir Dosyayı Okumak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modülerlik-ve-hata-yönetimini-geliştirmek"><a class="header" href="#modülerlik-ve-hata-yönetimini-geliştirmek">Modülerlik ve Hata Yönetimini Geliştirmek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-odaklı-geliştirme-ile-kütüphane-İşlevselliğini-artırmak"><a class="header" href="#test-odaklı-geliştirme-ile-kütüphane-İşlevselliğini-artırmak">Test Odaklı Geliştirme ile Kütüphane İşlevselliğini Artırmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ortam-değişkenleriyle-Çalışmak"><a class="header" href="#ortam-değişkenleriyle-Çalışmak">Ortam Değişkenleriyle Çalışmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hata-mesajlarını-standart-Çıktı-yerine-standart-hataya-yazmak"><a class="header" href="#hata-mesajlarını-standart-Çıktı-yerine-standart-hataya-yazmak">Hata Mesajlarını Standart Çıktı Yerine Standart Hataya Yazmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="İşlevsel-dil-Özellikleri-yineleyiciler-ve-kapamalar"><a class="header" href="#İşlevsel-dil-Özellikleri-yineleyiciler-ve-kapamalar">İşlevsel Dil Özellikleri: Yineleyiciler ve Kapamalar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kapamalar-ortam-değişkenlerini-yakalayabilen-İsimsiz-İşlevler"><a class="header" href="#kapamalar-ortam-değişkenlerini-yakalayabilen-İsimsiz-İşlevler">Kapamalar: Ortam Değişkenlerini Yakalayabilen İsimsiz İşlevler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yineleyiciler-ile-bir-dizi-Öğeyi-İşlemek"><a class="header" href="#yineleyiciler-ile-bir-dizi-Öğeyi-İşlemek">Yineleyiciler ile Bir Dizi Öğeyi İşlemek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-projemizi-geliştirmek"><a class="header" href="#io-projemizi-geliştirmek">I/O Projemizi Geliştirmek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performansı-karşılaştırmak-döngüler-vs-yineleyiciler"><a class="header" href="#performansı-karşılaştırmak-döngüler-vs-yineleyiciler">Performansı Karşılaştırmak: Döngüler vs. Yineleyiciler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-ve-cratesio-hakkında-daha-fazlası"><a class="header" href="#cargo-ve-cratesio-hakkında-daha-fazlası">Cargo ve Crates.io Hakkında Daha Fazlası</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derlemeleri-sürüm-profilleriyle-Özelleştirmek"><a class="header" href="#derlemeleri-sürüm-profilleriyle-Özelleştirmek">Derlemeleri Sürüm Profilleriyle Özelleştirmek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bir-sandığı-cratesio-Üzerinde-yayınlamak"><a class="header" href="#bir-sandığı-cratesio-Üzerinde-yayınlamak">Bir Sandığı Crates.io Üzerinde Yayınlamak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-Çalışma-alanları"><a class="header" href="#cargo-Çalışma-alanları">Cargo Çalışma Alanları</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cratesio-Üzerindeki-İkili-sandıkları-cargo-install-komutuyla-yüklemek"><a class="header" href="#cratesio-Üzerindeki-İkili-sandıkları-cargo-install-komutuyla-yüklemek">Crates.io Üzerindeki İkili Sandıkları cargo install Komutuyla Yüklemek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Özel-komutlarla-cargo-olanaklarını-genişletmek"><a class="header" href="#Özel-komutlarla-cargo-olanaklarını-genişletmek">Özel Komutlarla Cargo Olanaklarını Genişletmek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="akıllı-İşaretçiler"><a class="header" href="#akıllı-İşaretçiler">Akıllı İşaretçiler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yığındaki-veriler-İçin-box-kullanmak"><a class="header" href="#yığındaki-veriler-İçin-box-kullanmak">Yığındaki Veriler İçin Box<T> Kullanmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="akıllı-İşaretçilere-deref-Özelliğiyle-normal-referanslarmış-gibi-davranmak"><a class="header" href="#akıllı-İşaretçilere-deref-Özelliğiyle-normal-referanslarmış-gibi-davranmak">Akıllı İşaretçilere Deref Özelliğiyle Normal Referanslarmış Gibi Davranmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="temizlik-amaçlı-kod-Çalıştırmak-İçin-drop-Özelliğini-kullanmak"><a class="header" href="#temizlik-amaçlı-kod-Çalıştırmak-İçin-drop-Özelliğini-kullanmak">Temizlik Amaçlı Kod Çalıştırmak İçin Drop Özelliğini Kullanmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referans-sayılan-akıllı-İşaretçi-rc"><a class="header" href="#referans-sayılan-akıllı-İşaretçi-rc">Referans Sayılan Akıllı İşaretçi: Rc<T></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refcell-ve-İç-değişkenlik-modeli"><a class="header" href="#refcell-ve-İç-değişkenlik-modeli">RefCell<T> ve İç Değişkenlik Modeli</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referans-Çevrimleri-bellek-sızıntısına-yol-açabilir"><a class="header" href="#referans-Çevrimleri-bellek-sızıntısına-yol-açabilir">Referans Çevrimleri Bellek Sızıntısına Yol Açabilir</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="korkusuz-eşzamanlılık"><a class="header" href="#korkusuz-eşzamanlılık">Korkusuz Eşzamanlılık</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="İş-parçacıklarını-kullanmak"><a class="header" href="#İş-parçacıklarını-kullanmak">İş Parçacıklarını Kullanmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesajlaşma-yardımıyla-eş-zamanlı-programlama"><a class="header" href="#mesajlaşma-yardımıyla-eş-zamanlı-programlama">Mesajlaşma Yardımıyla Eş Zamanlı Programlama</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paylaşılan-durum-eşzamanlılığı"><a class="header" href="#paylaşılan-durum-eşzamanlılığı">Paylaşılan Durum Eşzamanlılığı</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync-and-send-Özellikleri-ile-genişletilebilir-eşzamanlılık"><a class="header" href="#sync-and-send-Özellikleri-ile-genişletilebilir-eşzamanlılık">Sync and Send Özellikleri ile Genişletilebilir Eşzamanlılık</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustın-nesne-yönelimli-programlama-Özellikleri"><a class="header" href="#rustın-nesne-yönelimli-programlama-Özellikleri">Rust'ın Nesne Yönelimli Programlama Özellikleri</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nesne-yönelimli-dillerin-Özellikleri"><a class="header" href="#nesne-yönelimli-dillerin-Özellikleri">Nesne Yönelimli Dillerin Özellikleri</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="farklı-türden-değerlere-İzin-veren-Özellik-nesnelerini-kullanmak"><a class="header" href="#farklı-türden-değerlere-İzin-veren-Özellik-nesnelerini-kullanmak">Farklı Türden Değerlere İzin Veren Özellik Nesnelerini Kullanmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nesne-yönelimli-tasarım-modeli-uygulamak"><a class="header" href="#nesne-yönelimli-tasarım-modeli-uygulamak">Nesne Yönelimli Tasarım Modeli Uygulamak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Örüntüler-ve-eşleme"><a class="header" href="#Örüntüler-ve-eşleme">Örüntüler ve Eşleme</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Örüntüler-her-yerde-kullanılabilir"><a class="header" href="#Örüntüler-her-yerde-kullanılabilir">Örüntüler Her Yerde Kullanılabilir</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Çürütülebilirlik-bir-Örüntünün-eşleşmeme-İhtimali"><a class="header" href="#Çürütülebilirlik-bir-Örüntünün-eşleşmeme-İhtimali">Çürütülebilirlik: Bir Örüntünün Eşleşmeme İhtimali</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Örüntü-sözdizimi"><a class="header" href="#Örüntü-sözdizimi">Örüntü Sözdizimi</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gelişmiş-Özellikler"><a class="header" href="#gelişmiş-Özellikler">Gelişmiş Özellikler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="güvensiz-kullanım"><a class="header" href="#güvensiz-kullanım">Güvensiz Kullanım</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gelişmiş-Özellikler-1"><a class="header" href="#gelişmiş-Özellikler-1">Gelişmiş Özellikler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gelişmiş-türler"><a class="header" href="#gelişmiş-türler">Gelişmiş Türler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gelişmiş-kapamalar-ve-İşlevler"><a class="header" href="#gelişmiş-kapamalar-ve-İşlevler">Gelişmiş Kapamalar ve İşlevler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="makrolar"><a class="header" href="#makrolar">Makrolar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="son-proje-Çok-İş-parçacıklı-bir-web-sunucusu-oluşturmak"><a class="header" href="#son-proje-Çok-İş-parçacıklı-bir-web-sunucusu-oluşturmak">Son Proje: Çok İş Parçacıklı Bir Web Sunucusu Oluşturmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tek-İş-parçacıklı-bir-web-sunucusu-oluşturmak"><a class="header" href="#tek-İş-parçacıklı-bir-web-sunucusu-oluşturmak">Tek İş Parçacıklı Bir Web Sunucusu Oluşturmak</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tek-İş-parçacıklı-sunucumuzu-Çok-İş-parçacıklı-bir-sunucuya-dönüştürmek"><a class="header" href="#tek-İş-parçacıklı-sunucumuzu-Çok-İş-parçacıklı-bir-sunucuya-dönüştürmek">Tek İş Parçacıklı Sunucumuzu Çok İş Parçacıklı Bir Sunucuya Dönüştürmek</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorunsuzca-kapatmak-ve-temizlik"><a class="header" href="#sorunsuzca-kapatmak-ve-temizlik">Sorunsuzca Kapatmak ve Temizlik</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ekler"><a class="header" href="#ekler">Ekler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a---anahtar-kelimeler"><a class="header" href="#a---anahtar-kelimeler">A - Anahtar Kelimeler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b---İşleçler-ve-semboller"><a class="header" href="#b---İşleçler-ve-semboller">B - İşleçler ve Semboller</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c---türetilebilir-Özellikler"><a class="header" href="#c---türetilebilir-Özellikler">C - Türetilebilir Özellikler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="d---faydalı-geliştirme-araçları"><a class="header" href="#d---faydalı-geliştirme-araçları">D - Faydalı Geliştirme Araçları</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="e---sürümler"><a class="header" href="#e---sürümler">E - Sürümler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f---kitabın-Çevirileri"><a class="header" href="#f---kitabın-Çevirileri">F - Kitabın Çevirileri</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="g---rust-nasıl-nightly-rust-yapılır"><a class="header" href="#g---rust-nasıl-nightly-rust-yapılır">G - Rust Nasıl “Nightly Rust” Yapılır?</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
